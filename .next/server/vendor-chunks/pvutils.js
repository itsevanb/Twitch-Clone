"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pvutils";
exports.ids = ["vendor-chunks/pvutils"];
exports.modules = {

/***/ "(rsc)/./node_modules/pvutils/build/utils.es.js":
/*!************************************************!*\
  !*** ./node_modules/pvutils/build/utils.es.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrayBufferToString: () => (/* binding */ arrayBufferToString),\n/* harmony export */   bufferToHexCodes: () => (/* binding */ bufferToHexCodes),\n/* harmony export */   checkBufferParams: () => (/* binding */ checkBufferParams),\n/* harmony export */   clearProps: () => (/* binding */ clearProps),\n/* harmony export */   fromBase64: () => (/* binding */ fromBase64),\n/* harmony export */   getParametersValue: () => (/* binding */ getParametersValue),\n/* harmony export */   getUTCDate: () => (/* binding */ getUTCDate),\n/* harmony export */   isEqualBuffer: () => (/* binding */ isEqualBuffer),\n/* harmony export */   nearestPowerOf2: () => (/* binding */ nearestPowerOf2),\n/* harmony export */   padNumber: () => (/* binding */ padNumber),\n/* harmony export */   stringToArrayBuffer: () => (/* binding */ stringToArrayBuffer),\n/* harmony export */   toBase64: () => (/* binding */ toBase64),\n/* harmony export */   utilConcatBuf: () => (/* binding */ utilConcatBuf),\n/* harmony export */   utilConcatView: () => (/* binding */ utilConcatView),\n/* harmony export */   utilDecodeTC: () => (/* binding */ utilDecodeTC),\n/* harmony export */   utilEncodeTC: () => (/* binding */ utilEncodeTC),\n/* harmony export */   utilFromBase: () => (/* binding */ utilFromBase),\n/* harmony export */   utilToBase: () => (/* binding */ utilToBase)\n/* harmony export */ });\n/*!\n Copyright (c) Peculiar Ventures, LLC\n*/ function getUTCDate(date) {\n    return new Date(date.getTime() + date.getTimezoneOffset() * 60000);\n}\nfunction getParametersValue(parameters, name, defaultValue) {\n    var _a;\n    if (parameters instanceof Object === false) {\n        return defaultValue;\n    }\n    return (_a = parameters[name]) !== null && _a !== void 0 ? _a : defaultValue;\n}\nfunction bufferToHexCodes(inputBuffer, inputOffset = 0, inputLength = inputBuffer.byteLength - inputOffset, insertSpace = false) {\n    let result = \"\";\n    for (const item of new Uint8Array(inputBuffer, inputOffset, inputLength)){\n        const str = item.toString(16).toUpperCase();\n        if (str.length === 1) {\n            result += \"0\";\n        }\n        result += str;\n        if (insertSpace) {\n            result += \" \";\n        }\n    }\n    return result.trim();\n}\nfunction checkBufferParams(baseBlock, inputBuffer, inputOffset, inputLength) {\n    if (!(inputBuffer instanceof ArrayBuffer)) {\n        baseBlock.error = 'Wrong parameter: inputBuffer must be \"ArrayBuffer\"';\n        return false;\n    }\n    if (!inputBuffer.byteLength) {\n        baseBlock.error = \"Wrong parameter: inputBuffer has zero length\";\n        return false;\n    }\n    if (inputOffset < 0) {\n        baseBlock.error = \"Wrong parameter: inputOffset less than zero\";\n        return false;\n    }\n    if (inputLength < 0) {\n        baseBlock.error = \"Wrong parameter: inputLength less than zero\";\n        return false;\n    }\n    if (inputBuffer.byteLength - inputOffset - inputLength < 0) {\n        baseBlock.error = \"End of input reached before message was fully decoded (inconsistent offset and length values)\";\n        return false;\n    }\n    return true;\n}\nfunction utilFromBase(inputBuffer, inputBase) {\n    let result = 0;\n    if (inputBuffer.length === 1) {\n        return inputBuffer[0];\n    }\n    for(let i = inputBuffer.length - 1; i >= 0; i--){\n        result += inputBuffer[inputBuffer.length - 1 - i] * Math.pow(2, inputBase * i);\n    }\n    return result;\n}\nfunction utilToBase(value, base, reserved = -1) {\n    const internalReserved = reserved;\n    let internalValue = value;\n    let result = 0;\n    let biggest = Math.pow(2, base);\n    for(let i = 1; i < 8; i++){\n        if (value < biggest) {\n            let retBuf;\n            if (internalReserved < 0) {\n                retBuf = new ArrayBuffer(i);\n                result = i;\n            } else {\n                if (internalReserved < i) {\n                    return new ArrayBuffer(0);\n                }\n                retBuf = new ArrayBuffer(internalReserved);\n                result = internalReserved;\n            }\n            const retView = new Uint8Array(retBuf);\n            for(let j = i - 1; j >= 0; j--){\n                const basis = Math.pow(2, j * base);\n                retView[result - j - 1] = Math.floor(internalValue / basis);\n                internalValue -= retView[result - j - 1] * basis;\n            }\n            return retBuf;\n        }\n        biggest *= Math.pow(2, base);\n    }\n    return new ArrayBuffer(0);\n}\nfunction utilConcatBuf(...buffers) {\n    let outputLength = 0;\n    let prevLength = 0;\n    for (const buffer of buffers){\n        outputLength += buffer.byteLength;\n    }\n    const retBuf = new ArrayBuffer(outputLength);\n    const retView = new Uint8Array(retBuf);\n    for (const buffer of buffers){\n        retView.set(new Uint8Array(buffer), prevLength);\n        prevLength += buffer.byteLength;\n    }\n    return retBuf;\n}\nfunction utilConcatView(...views) {\n    let outputLength = 0;\n    let prevLength = 0;\n    for (const view of views){\n        outputLength += view.length;\n    }\n    const retBuf = new ArrayBuffer(outputLength);\n    const retView = new Uint8Array(retBuf);\n    for (const view of views){\n        retView.set(view, prevLength);\n        prevLength += view.length;\n    }\n    return retView;\n}\nfunction utilDecodeTC() {\n    const buf = new Uint8Array(this.valueHex);\n    if (this.valueHex.byteLength >= 2) {\n        const condition1 = buf[0] === 0xFF && buf[1] & 0x80;\n        const condition2 = buf[0] === 0x00 && (buf[1] & 0x80) === 0x00;\n        if (condition1 || condition2) {\n            this.warnings.push(\"Needlessly long format\");\n        }\n    }\n    const bigIntBuffer = new ArrayBuffer(this.valueHex.byteLength);\n    const bigIntView = new Uint8Array(bigIntBuffer);\n    for(let i = 0; i < this.valueHex.byteLength; i++){\n        bigIntView[i] = 0;\n    }\n    bigIntView[0] = buf[0] & 0x80;\n    const bigInt = utilFromBase(bigIntView, 8);\n    const smallIntBuffer = new ArrayBuffer(this.valueHex.byteLength);\n    const smallIntView = new Uint8Array(smallIntBuffer);\n    for(let j = 0; j < this.valueHex.byteLength; j++){\n        smallIntView[j] = buf[j];\n    }\n    smallIntView[0] &= 0x7F;\n    const smallInt = utilFromBase(smallIntView, 8);\n    return smallInt - bigInt;\n}\nfunction utilEncodeTC(value) {\n    const modValue = value < 0 ? value * -1 : value;\n    let bigInt = 128;\n    for(let i = 1; i < 8; i++){\n        if (modValue <= bigInt) {\n            if (value < 0) {\n                const smallInt = bigInt - modValue;\n                const retBuf = utilToBase(smallInt, 8, i);\n                const retView = new Uint8Array(retBuf);\n                retView[0] |= 0x80;\n                return retBuf;\n            }\n            let retBuf = utilToBase(modValue, 8, i);\n            let retView = new Uint8Array(retBuf);\n            if (retView[0] & 0x80) {\n                const tempBuf = retBuf.slice(0);\n                const tempView = new Uint8Array(tempBuf);\n                retBuf = new ArrayBuffer(retBuf.byteLength + 1);\n                retView = new Uint8Array(retBuf);\n                for(let k = 0; k < tempBuf.byteLength; k++){\n                    retView[k + 1] = tempView[k];\n                }\n                retView[0] = 0x00;\n            }\n            return retBuf;\n        }\n        bigInt *= Math.pow(2, 8);\n    }\n    return new ArrayBuffer(0);\n}\nfunction isEqualBuffer(inputBuffer1, inputBuffer2) {\n    if (inputBuffer1.byteLength !== inputBuffer2.byteLength) {\n        return false;\n    }\n    const view1 = new Uint8Array(inputBuffer1);\n    const view2 = new Uint8Array(inputBuffer2);\n    for(let i = 0; i < view1.length; i++){\n        if (view1[i] !== view2[i]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction padNumber(inputNumber, fullLength) {\n    const str = inputNumber.toString(10);\n    if (fullLength < str.length) {\n        return \"\";\n    }\n    const dif = fullLength - str.length;\n    const padding = new Array(dif);\n    for(let i = 0; i < dif; i++){\n        padding[i] = \"0\";\n    }\n    const paddingString = padding.join(\"\");\n    return paddingString.concat(str);\n}\nconst base64Template = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\nconst base64UrlTemplate = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\";\nfunction toBase64(input, useUrlTemplate = false, skipPadding = false, skipLeadingZeros = false) {\n    let i = 0;\n    let flag1 = 0;\n    let flag2 = 0;\n    let output = \"\";\n    const template = useUrlTemplate ? base64UrlTemplate : base64Template;\n    if (skipLeadingZeros) {\n        let nonZeroPosition = 0;\n        for(let i = 0; i < input.length; i++){\n            if (input.charCodeAt(i) !== 0) {\n                nonZeroPosition = i;\n                break;\n            }\n        }\n        input = input.slice(nonZeroPosition);\n    }\n    while(i < input.length){\n        const chr1 = input.charCodeAt(i++);\n        if (i >= input.length) {\n            flag1 = 1;\n        }\n        const chr2 = input.charCodeAt(i++);\n        if (i >= input.length) {\n            flag2 = 1;\n        }\n        const chr3 = input.charCodeAt(i++);\n        const enc1 = chr1 >> 2;\n        const enc2 = (chr1 & 0x03) << 4 | chr2 >> 4;\n        let enc3 = (chr2 & 0x0F) << 2 | chr3 >> 6;\n        let enc4 = chr3 & 0x3F;\n        if (flag1 === 1) {\n            enc3 = enc4 = 64;\n        } else {\n            if (flag2 === 1) {\n                enc4 = 64;\n            }\n        }\n        if (skipPadding) {\n            if (enc3 === 64) {\n                output += `${template.charAt(enc1)}${template.charAt(enc2)}`;\n            } else {\n                if (enc4 === 64) {\n                    output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}`;\n                } else {\n                    output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;\n                }\n            }\n        } else {\n            output += `${template.charAt(enc1)}${template.charAt(enc2)}${template.charAt(enc3)}${template.charAt(enc4)}`;\n        }\n    }\n    return output;\n}\nfunction fromBase64(input, useUrlTemplate = false, cutTailZeros = false) {\n    const template = useUrlTemplate ? base64UrlTemplate : base64Template;\n    function indexOf(toSearch) {\n        for(let i = 0; i < 64; i++){\n            if (template.charAt(i) === toSearch) return i;\n        }\n        return 64;\n    }\n    function test(incoming) {\n        return incoming === 64 ? 0x00 : incoming;\n    }\n    let i = 0;\n    let output = \"\";\n    while(i < input.length){\n        const enc1 = indexOf(input.charAt(i++));\n        const enc2 = i >= input.length ? 0x00 : indexOf(input.charAt(i++));\n        const enc3 = i >= input.length ? 0x00 : indexOf(input.charAt(i++));\n        const enc4 = i >= input.length ? 0x00 : indexOf(input.charAt(i++));\n        const chr1 = test(enc1) << 2 | test(enc2) >> 4;\n        const chr2 = (test(enc2) & 0x0F) << 4 | test(enc3) >> 2;\n        const chr3 = (test(enc3) & 0x03) << 6 | test(enc4);\n        output += String.fromCharCode(chr1);\n        if (enc3 !== 64) {\n            output += String.fromCharCode(chr2);\n        }\n        if (enc4 !== 64) {\n            output += String.fromCharCode(chr3);\n        }\n    }\n    if (cutTailZeros) {\n        const outputLength = output.length;\n        let nonZeroStart = -1;\n        for(let i = outputLength - 1; i >= 0; i--){\n            if (output.charCodeAt(i) !== 0) {\n                nonZeroStart = i;\n                break;\n            }\n        }\n        if (nonZeroStart !== -1) {\n            output = output.slice(0, nonZeroStart + 1);\n        } else {\n            output = \"\";\n        }\n    }\n    return output;\n}\nfunction arrayBufferToString(buffer) {\n    let resultString = \"\";\n    const view = new Uint8Array(buffer);\n    for (const element of view){\n        resultString += String.fromCharCode(element);\n    }\n    return resultString;\n}\nfunction stringToArrayBuffer(str) {\n    const stringLength = str.length;\n    const resultBuffer = new ArrayBuffer(stringLength);\n    const resultView = new Uint8Array(resultBuffer);\n    for(let i = 0; i < stringLength; i++){\n        resultView[i] = str.charCodeAt(i);\n    }\n    return resultBuffer;\n}\nconst log2 = Math.log(2);\nfunction nearestPowerOf2(length) {\n    const base = Math.log(length) / log2;\n    const floor = Math.floor(base);\n    const round = Math.round(base);\n    return floor === round ? floor : round;\n}\nfunction clearProps(object, propsArray) {\n    for (const prop of propsArray){\n        delete object[prop];\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcHZ1dGlscy9idWlsZC91dGlscy5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTs7QUFFQSxHQUVBLFNBQVNBLFdBQVdDLElBQUk7SUFDcEIsT0FBTyxJQUFJQyxLQUFLRCxLQUFLRSxPQUFPLEtBQU1GLEtBQUtHLGlCQUFpQixLQUFLO0FBQ2pFO0FBQ0EsU0FBU0MsbUJBQW1CQyxVQUFVLEVBQUVDLElBQUksRUFBRUMsWUFBWTtJQUN0RCxJQUFJQztJQUNKLElBQUksc0JBQXVCQyxXQUFZLE9BQU87UUFDMUMsT0FBT0Y7SUFDWDtJQUNBLE9BQU8sQ0FBQ0MsS0FBS0gsVUFBVSxDQUFDQyxLQUFLLE1BQU0sUUFBUUUsT0FBTyxLQUFLLElBQUlBLEtBQUtEO0FBQ3BFO0FBQ0EsU0FBU0csaUJBQWlCQyxXQUFXLEVBQUVDLGNBQWMsQ0FBQyxFQUFFQyxjQUFlRixZQUFZRyxVQUFVLEdBQUdGLFdBQVksRUFBRUcsY0FBYyxLQUFLO0lBQzdILElBQUlDLFNBQVM7SUFDYixLQUFLLE1BQU1DLFFBQVMsSUFBSUMsV0FBV1AsYUFBYUMsYUFBYUMsYUFBZTtRQUN4RSxNQUFNTSxNQUFNRixLQUFLRyxRQUFRLENBQUMsSUFBSUMsV0FBVztRQUN6QyxJQUFJRixJQUFJRyxNQUFNLEtBQUssR0FBRztZQUNsQk4sVUFBVTtRQUNkO1FBQ0FBLFVBQVVHO1FBQ1YsSUFBSUosYUFBYTtZQUNiQyxVQUFVO1FBQ2Q7SUFDSjtJQUNBLE9BQU9BLE9BQU9PLElBQUk7QUFDdEI7QUFDQSxTQUFTQyxrQkFBa0JDLFNBQVMsRUFBRWQsV0FBVyxFQUFFQyxXQUFXLEVBQUVDLFdBQVc7SUFDdkUsSUFBSSxDQUFFRixDQUFBQSx1QkFBdUJlLFdBQVUsR0FBSTtRQUN2Q0QsVUFBVUUsS0FBSyxHQUFHO1FBQ2xCLE9BQU87SUFDWDtJQUNBLElBQUksQ0FBQ2hCLFlBQVlHLFVBQVUsRUFBRTtRQUN6QlcsVUFBVUUsS0FBSyxHQUFH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RyxZQUFZK0Y7SUFDckMsTUFBTUUsYUFBYSxJQUFJekcsV0FBV3dHO0lBQ2xDLElBQUssSUFBSTVGLElBQUksR0FBR0EsSUFBSTJGLGNBQWMzRixJQUFLO1FBQ25DNkYsVUFBVSxDQUFDN0YsRUFBRSxHQUFHWCxJQUFJZ0YsVUFBVSxDQUFDckU7SUFDbkM7SUFDQSxPQUFPNEY7QUFDWDtBQUNBLE1BQU1FLE9BQU83RixLQUFLOEYsR0FBRyxDQUFDO0FBQ3RCLFNBQVNDLGdCQUFnQnhHLE1BQU07SUFDM0IsTUFBTWEsT0FBUUosS0FBSzhGLEdBQUcsQ0FBQ3ZHLFVBQVVzRztJQUNqQyxNQUFNaEYsUUFBUWIsS0FBS2EsS0FBSyxDQUFDVDtJQUN6QixNQUFNNEYsUUFBUWhHLEtBQUtnRyxLQUFLLENBQUM1RjtJQUN6QixPQUFRLFVBQVc0RixRQUFTbkYsUUFBUW1GO0FBQ3hDO0FBQ0EsU0FBU0MsV0FBV0MsTUFBTSxFQUFFQyxVQUFVO0lBQ2xDLEtBQUssTUFBTUMsUUFBUUQsV0FBWTtRQUMzQixPQUFPRCxNQUFNLENBQUNFLEtBQUs7SUFDdkI7QUFDSjtBQUUyUiIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpZGVvLXN0cmVhbWluZy8uL25vZGVfbW9kdWxlcy9wdnV0aWxzL2J1aWxkL3V0aWxzLmVzLmpzPzU2MWEiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gQ29weXJpZ2h0IChjKSBQZWN1bGlhciBWZW50dXJlcywgTExDXG4qL1xuXG5mdW5jdGlvbiBnZXRVVENEYXRlKGRhdGUpIHtcclxuICAgIHJldHVybiBuZXcgRGF0ZShkYXRlLmdldFRpbWUoKSArIChkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCkgKiA2MDAwMCkpO1xyXG59XHJcbmZ1bmN0aW9uIGdldFBhcmFtZXRlcnNWYWx1ZShwYXJhbWV0ZXJzLCBuYW1lLCBkZWZhdWx0VmFsdWUpIHtcclxuICAgIHZhciBfYTtcclxuICAgIGlmICgocGFyYW1ldGVycyBpbnN0YW5jZW9mIE9iamVjdCkgPT09IGZhbHNlKSB7XHJcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiAoX2EgPSBwYXJhbWV0ZXJzW25hbWVdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkZWZhdWx0VmFsdWU7XHJcbn1cclxuZnVuY3Rpb24gYnVmZmVyVG9IZXhDb2RlcyhpbnB1dEJ1ZmZlciwgaW5wdXRPZmZzZXQgPSAwLCBpbnB1dExlbmd0aCA9IChpbnB1dEJ1ZmZlci5ieXRlTGVuZ3RoIC0gaW5wdXRPZmZzZXQpLCBpbnNlcnRTcGFjZSA9IGZhbHNlKSB7XHJcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcclxuICAgIGZvciAoY29uc3QgaXRlbSBvZiAobmV3IFVpbnQ4QXJyYXkoaW5wdXRCdWZmZXIsIGlucHV0T2Zmc2V0LCBpbnB1dExlbmd0aCkpKSB7XHJcbiAgICAgICAgY29uc3Qgc3RyID0gaXRlbS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcclxuICAgICAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgICAgICByZXN1bHQgKz0gXCIwXCI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlc3VsdCArPSBzdHI7XHJcbiAgICAgICAgaWYgKGluc2VydFNwYWNlKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIiBcIjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0LnRyaW0oKTtcclxufVxyXG5mdW5jdGlvbiBjaGVja0J1ZmZlclBhcmFtcyhiYXNlQmxvY2ssIGlucHV0QnVmZmVyLCBpbnB1dE9mZnNldCwgaW5wdXRMZW5ndGgpIHtcclxuICAgIGlmICghKGlucHV0QnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpKSB7XHJcbiAgICAgICAgYmFzZUJsb2NrLmVycm9yID0gXCJXcm9uZyBwYXJhbWV0ZXI6IGlucHV0QnVmZmVyIG11c3QgYmUgXFxcIkFycmF5QnVmZmVyXFxcIlwiO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICghaW5wdXRCdWZmZXIuYnl0ZUxlbmd0aCkge1xyXG4gICAgICAgIGJhc2VCbG9jay5lcnJvciA9IFwiV3JvbmcgcGFyYW1ldGVyOiBpbnB1dEJ1ZmZlciBoYXMgemVybyBsZW5ndGhcIjtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAoaW5wdXRPZmZzZXQgPCAwKSB7XHJcbiAgICAgICAgYmFzZUJsb2NrLmVycm9yID0gXCJXcm9uZyBwYXJhbWV0ZXI6IGlucHV0T2Zmc2V0IGxlc3MgdGhhbiB6ZXJvXCI7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKGlucHV0TGVuZ3RoIDwgMCkge1xyXG4gICAgICAgIGJhc2VCbG9jay5lcnJvciA9IFwiV3JvbmcgcGFyYW1ldGVyOiBpbnB1dExlbmd0aCBsZXNzIHRoYW4gemVyb1wiO1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGlmICgoaW5wdXRCdWZmZXIuYnl0ZUxlbmd0aCAtIGlucHV0T2Zmc2V0IC0gaW5wdXRMZW5ndGgpIDwgMCkge1xyXG4gICAgICAgIGJhc2VCbG9jay5lcnJvciA9IFwiRW5kIG9mIGlucHV0IHJlYWNoZWQgYmVmb3JlIG1lc3NhZ2Ugd2FzIGZ1bGx5IGRlY29kZWQgKGluY29uc2lzdGVudCBvZmZzZXQgYW5kIGxlbmd0aCB2YWx1ZXMpXCI7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gdXRpbEZyb21CYXNlKGlucHV0QnVmZmVyLCBpbnB1dEJhc2UpIHtcclxuICAgIGxldCByZXN1bHQgPSAwO1xyXG4gICAgaWYgKGlucHV0QnVmZmVyLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICAgIHJldHVybiBpbnB1dEJ1ZmZlclswXTtcclxuICAgIH1cclxuICAgIGZvciAobGV0IGkgPSAoaW5wdXRCdWZmZXIubGVuZ3RoIC0gMSk7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgcmVzdWx0ICs9IGlucHV0QnVmZmVyWyhpbnB1dEJ1ZmZlci5sZW5ndGggLSAxKSAtIGldICogTWF0aC5wb3coMiwgaW5wdXRCYXNlICogaSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmZ1bmN0aW9uIHV0aWxUb0Jhc2UodmFsdWUsIGJhc2UsIHJlc2VydmVkID0gKC0xKSkge1xyXG4gICAgY29uc3QgaW50ZXJuYWxSZXNlcnZlZCA9IHJlc2VydmVkO1xyXG4gICAgbGV0IGludGVybmFsVmFsdWUgPSB2YWx1ZTtcclxuICAgIGxldCByZXN1bHQgPSAwO1xyXG4gICAgbGV0IGJpZ2dlc3QgPSBNYXRoLnBvdygyLCBiYXNlKTtcclxuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgODsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHZhbHVlIDwgYmlnZ2VzdCkge1xyXG4gICAgICAgICAgICBsZXQgcmV0QnVmO1xyXG4gICAgICAgICAgICBpZiAoaW50ZXJuYWxSZXNlcnZlZCA8IDApIHtcclxuICAgICAgICAgICAgICAgIHJldEJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihpKTtcclxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IGk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW50ZXJuYWxSZXNlcnZlZCA8IGkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKG5ldyBBcnJheUJ1ZmZlcigwKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXRCdWYgPSBuZXcgQXJyYXlCdWZmZXIoaW50ZXJuYWxSZXNlcnZlZCk7XHJcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpbnRlcm5hbFJlc2VydmVkO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnN0IHJldFZpZXcgPSBuZXcgVWludDhBcnJheShyZXRCdWYpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBqID0gKGkgLSAxKTsgaiA+PSAwOyBqLS0pIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGJhc2lzID0gTWF0aC5wb3coMiwgaiAqIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgcmV0Vmlld1tyZXN1bHQgLSBqIC0gMV0gPSBNYXRoLmZsb29yKGludGVybmFsVmFsdWUgLyBiYXNpcyk7XHJcbiAgICAgICAgICAgICAgICBpbnRlcm5hbFZhbHVlIC09IChyZXRWaWV3W3Jlc3VsdCAtIGogLSAxXSkgKiBiYXNpcztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmV0QnVmO1xyXG4gICAgICAgIH1cclxuICAgICAgICBiaWdnZXN0ICo9IE1hdGgucG93KDIsIGJhc2UpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG5ldyBBcnJheUJ1ZmZlcigwKTtcclxufVxyXG5mdW5jdGlvbiB1dGlsQ29uY2F0QnVmKC4uLmJ1ZmZlcnMpIHtcclxuICAgIGxldCBvdXRwdXRMZW5ndGggPSAwO1xyXG4gICAgbGV0IHByZXZMZW5ndGggPSAwO1xyXG4gICAgZm9yIChjb25zdCBidWZmZXIgb2YgYnVmZmVycykge1xyXG4gICAgICAgIG91dHB1dExlbmd0aCArPSBidWZmZXIuYnl0ZUxlbmd0aDtcclxuICAgIH1cclxuICAgIGNvbnN0IHJldEJ1ZiA9IG5ldyBBcnJheUJ1ZmZlcihvdXRwdXRMZW5ndGgpO1xyXG4gICAgY29uc3QgcmV0VmlldyA9IG5ldyBVaW50OEFycmF5KHJldEJ1Zik7XHJcbiAgICBmb3IgKGNvbnN0IGJ1ZmZlciBvZiBidWZmZXJzKSB7XHJcbiAgICAgICAgcmV0Vmlldy5zZXQobmV3IFVpbnQ4QXJyYXkoYnVmZmVyKSwgcHJldkxlbmd0aCk7XHJcbiAgICAgICAgcHJldkxlbmd0aCArPSBidWZmZXIuYnl0ZUxlbmd0aDtcclxuICAgIH1cclxuICAgIHJldHVybiByZXRCdWY7XHJcbn1cclxuZnVuY3Rpb24gdXRpbENvbmNhdFZpZXcoLi4udmlld3MpIHtcclxuICAgIGxldCBvdXRwdXRMZW5ndGggPSAwO1xyXG4gICAgbGV0IHByZXZMZW5ndGggPSAwO1xyXG4gICAgZm9yIChjb25zdCB2aWV3IG9mIHZpZXdzKSB7XHJcbiAgICAgICAgb3V0cHV0TGVuZ3RoICs9IHZpZXcubGVuZ3RoO1xyXG4gICAgfVxyXG4gICAgY29uc3QgcmV0QnVmID0gbmV3IEFycmF5QnVmZmVyKG91dHB1dExlbmd0aCk7XHJcbiAgICBjb25zdCByZXRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkocmV0QnVmKTtcclxuICAgIGZvciAoY29uc3QgdmlldyBvZiB2aWV3cykge1xyXG4gICAgICAgIHJldFZpZXcuc2V0KHZpZXcsIHByZXZMZW5ndGgpO1xyXG4gICAgICAgIHByZXZMZW5ndGggKz0gdmlldy5sZW5ndGg7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmV0VmlldztcclxufVxyXG5mdW5jdGlvbiB1dGlsRGVjb2RlVEMoKSB7XHJcbiAgICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheSh0aGlzLnZhbHVlSGV4KTtcclxuICAgIGlmICh0aGlzLnZhbHVlSGV4LmJ5dGVMZW5ndGggPj0gMikge1xyXG4gICAgICAgIGNvbnN0IGNvbmRpdGlvbjEgPSAoYnVmWzBdID09PSAweEZGKSAmJiAoYnVmWzFdICYgMHg4MCk7XHJcbiAgICAgICAgY29uc3QgY29uZGl0aW9uMiA9IChidWZbMF0gPT09IDB4MDApICYmICgoYnVmWzFdICYgMHg4MCkgPT09IDB4MDApO1xyXG4gICAgICAgIGlmIChjb25kaXRpb24xIHx8IGNvbmRpdGlvbjIpIHtcclxuICAgICAgICAgICAgdGhpcy53YXJuaW5ncy5wdXNoKFwiTmVlZGxlc3NseSBsb25nIGZvcm1hdFwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBjb25zdCBiaWdJbnRCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIodGhpcy52YWx1ZUhleC5ieXRlTGVuZ3RoKTtcclxuICAgIGNvbnN0IGJpZ0ludFZpZXcgPSBuZXcgVWludDhBcnJheShiaWdJbnRCdWZmZXIpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnZhbHVlSGV4LmJ5dGVMZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGJpZ0ludFZpZXdbaV0gPSAwO1xyXG4gICAgfVxyXG4gICAgYmlnSW50Vmlld1swXSA9IChidWZbMF0gJiAweDgwKTtcclxuICAgIGNvbnN0IGJpZ0ludCA9IHV0aWxGcm9tQmFzZShiaWdJbnRWaWV3LCA4KTtcclxuICAgIGNvbnN0IHNtYWxsSW50QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHRoaXMudmFsdWVIZXguYnl0ZUxlbmd0aCk7XHJcbiAgICBjb25zdCBzbWFsbEludFZpZXcgPSBuZXcgVWludDhBcnJheShzbWFsbEludEJ1ZmZlcik7XHJcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IHRoaXMudmFsdWVIZXguYnl0ZUxlbmd0aDsgaisrKSB7XHJcbiAgICAgICAgc21hbGxJbnRWaWV3W2pdID0gYnVmW2pdO1xyXG4gICAgfVxyXG4gICAgc21hbGxJbnRWaWV3WzBdICY9IDB4N0Y7XHJcbiAgICBjb25zdCBzbWFsbEludCA9IHV0aWxGcm9tQmFzZShzbWFsbEludFZpZXcsIDgpO1xyXG4gICAgcmV0dXJuIChzbWFsbEludCAtIGJpZ0ludCk7XHJcbn1cclxuZnVuY3Rpb24gdXRpbEVuY29kZVRDKHZhbHVlKSB7XHJcbiAgICBjb25zdCBtb2RWYWx1ZSA9ICh2YWx1ZSA8IDApID8gKHZhbHVlICogKC0xKSkgOiB2YWx1ZTtcclxuICAgIGxldCBiaWdJbnQgPSAxMjg7XHJcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IDg7IGkrKykge1xyXG4gICAgICAgIGlmIChtb2RWYWx1ZSA8PSBiaWdJbnQpIHtcclxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMCkge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc21hbGxJbnQgPSBiaWdJbnQgLSBtb2RWYWx1ZTtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJldEJ1ZiA9IHV0aWxUb0Jhc2Uoc21hbGxJbnQsIDgsIGkpO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmV0VmlldyA9IG5ldyBVaW50OEFycmF5KHJldEJ1Zik7XHJcbiAgICAgICAgICAgICAgICByZXRWaWV3WzBdIHw9IDB4ODA7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0QnVmO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxldCByZXRCdWYgPSB1dGlsVG9CYXNlKG1vZFZhbHVlLCA4LCBpKTtcclxuICAgICAgICAgICAgbGV0IHJldFZpZXcgPSBuZXcgVWludDhBcnJheShyZXRCdWYpO1xyXG4gICAgICAgICAgICBpZiAocmV0Vmlld1swXSAmIDB4ODApIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBCdWYgPSByZXRCdWYuc2xpY2UoMCk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCB0ZW1wVmlldyA9IG5ldyBVaW50OEFycmF5KHRlbXBCdWYpO1xyXG4gICAgICAgICAgICAgICAgcmV0QnVmID0gbmV3IEFycmF5QnVmZmVyKHJldEJ1Zi5ieXRlTGVuZ3RoICsgMSk7XHJcbiAgICAgICAgICAgICAgICByZXRWaWV3ID0gbmV3IFVpbnQ4QXJyYXkocmV0QnVmKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IGsgPSAwOyBrIDwgdGVtcEJ1Zi5ieXRlTGVuZ3RoOyBrKyspIHtcclxuICAgICAgICAgICAgICAgICAgICByZXRWaWV3W2sgKyAxXSA9IHRlbXBWaWV3W2tdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0Vmlld1swXSA9IDB4MDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJldEJ1ZjtcclxuICAgICAgICB9XHJcbiAgICAgICAgYmlnSW50ICo9IE1hdGgucG93KDIsIDgpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIChuZXcgQXJyYXlCdWZmZXIoMCkpO1xyXG59XHJcbmZ1bmN0aW9uIGlzRXF1YWxCdWZmZXIoaW5wdXRCdWZmZXIxLCBpbnB1dEJ1ZmZlcjIpIHtcclxuICAgIGlmIChpbnB1dEJ1ZmZlcjEuYnl0ZUxlbmd0aCAhPT0gaW5wdXRCdWZmZXIyLmJ5dGVMZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBjb25zdCB2aWV3MSA9IG5ldyBVaW50OEFycmF5KGlucHV0QnVmZmVyMSk7XHJcbiAgICBjb25zdCB2aWV3MiA9IG5ldyBVaW50OEFycmF5KGlucHV0QnVmZmVyMik7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZpZXcxLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKHZpZXcxW2ldICE9PSB2aWV3MltpXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuZnVuY3Rpb24gcGFkTnVtYmVyKGlucHV0TnVtYmVyLCBmdWxsTGVuZ3RoKSB7XHJcbiAgICBjb25zdCBzdHIgPSBpbnB1dE51bWJlci50b1N0cmluZygxMCk7XHJcbiAgICBpZiAoZnVsbExlbmd0aCA8IHN0ci5sZW5ndGgpIHtcclxuICAgICAgICByZXR1cm4gXCJcIjtcclxuICAgIH1cclxuICAgIGNvbnN0IGRpZiA9IGZ1bGxMZW5ndGggLSBzdHIubGVuZ3RoO1xyXG4gICAgY29uc3QgcGFkZGluZyA9IG5ldyBBcnJheShkaWYpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaWY7IGkrKykge1xyXG4gICAgICAgIHBhZGRpbmdbaV0gPSBcIjBcIjtcclxuICAgIH1cclxuICAgIGNvbnN0IHBhZGRpbmdTdHJpbmcgPSBwYWRkaW5nLmpvaW4oXCJcIik7XHJcbiAgICByZXR1cm4gcGFkZGluZ1N0cmluZy5jb25jYXQoc3RyKTtcclxufVxyXG5jb25zdCBiYXNlNjRUZW1wbGF0ZSA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIjtcclxuY29uc3QgYmFzZTY0VXJsVGVtcGxhdGUgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5LV89XCI7XHJcbmZ1bmN0aW9uIHRvQmFzZTY0KGlucHV0LCB1c2VVcmxUZW1wbGF0ZSA9IGZhbHNlLCBza2lwUGFkZGluZyA9IGZhbHNlLCBza2lwTGVhZGluZ1plcm9zID0gZmFsc2UpIHtcclxuICAgIGxldCBpID0gMDtcclxuICAgIGxldCBmbGFnMSA9IDA7XHJcbiAgICBsZXQgZmxhZzIgPSAwO1xyXG4gICAgbGV0IG91dHB1dCA9IFwiXCI7XHJcbiAgICBjb25zdCB0ZW1wbGF0ZSA9ICh1c2VVcmxUZW1wbGF0ZSkgPyBiYXNlNjRVcmxUZW1wbGF0ZSA6IGJhc2U2NFRlbXBsYXRlO1xyXG4gICAgaWYgKHNraXBMZWFkaW5nWmVyb3MpIHtcclxuICAgICAgICBsZXQgbm9uWmVyb1Bvc2l0aW9uID0gMDtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KGkpICE9PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBub25aZXJvUG9zaXRpb24gPSBpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaW5wdXQgPSBpbnB1dC5zbGljZShub25aZXJvUG9zaXRpb24pO1xyXG4gICAgfVxyXG4gICAgd2hpbGUgKGkgPCBpbnB1dC5sZW5ndGgpIHtcclxuICAgICAgICBjb25zdCBjaHIxID0gaW5wdXQuY2hhckNvZGVBdChpKyspO1xyXG4gICAgICAgIGlmIChpID49IGlucHV0Lmxlbmd0aCkge1xyXG4gICAgICAgICAgICBmbGFnMSA9IDE7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGNocjIgPSBpbnB1dC5jaGFyQ29kZUF0KGkrKyk7XHJcbiAgICAgICAgaWYgKGkgPj0gaW5wdXQubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGZsYWcyID0gMTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgY2hyMyA9IGlucHV0LmNoYXJDb2RlQXQoaSsrKTtcclxuICAgICAgICBjb25zdCBlbmMxID0gY2hyMSA+PiAyO1xyXG4gICAgICAgIGNvbnN0IGVuYzIgPSAoKGNocjEgJiAweDAzKSA8PCA0KSB8IChjaHIyID4+IDQpO1xyXG4gICAgICAgIGxldCBlbmMzID0gKChjaHIyICYgMHgwRikgPDwgMikgfCAoY2hyMyA+PiA2KTtcclxuICAgICAgICBsZXQgZW5jNCA9IGNocjMgJiAweDNGO1xyXG4gICAgICAgIGlmIChmbGFnMSA9PT0gMSkge1xyXG4gICAgICAgICAgICBlbmMzID0gZW5jNCA9IDY0O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgaWYgKGZsYWcyID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBlbmM0ID0gNjQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHNraXBQYWRkaW5nKSB7XHJcbiAgICAgICAgICAgIGlmIChlbmMzID09PSA2NCkge1xyXG4gICAgICAgICAgICAgICAgb3V0cHV0ICs9IGAke3RlbXBsYXRlLmNoYXJBdChlbmMxKX0ke3RlbXBsYXRlLmNoYXJBdChlbmMyKX1gO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgaWYgKGVuYzQgPT09IDY0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IGAke3RlbXBsYXRlLmNoYXJBdChlbmMxKX0ke3RlbXBsYXRlLmNoYXJBdChlbmMyKX0ke3RlbXBsYXRlLmNoYXJBdChlbmMzKX1gO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0ICs9IGAke3RlbXBsYXRlLmNoYXJBdChlbmMxKX0ke3RlbXBsYXRlLmNoYXJBdChlbmMyKX0ke3RlbXBsYXRlLmNoYXJBdChlbmMzKX0ke3RlbXBsYXRlLmNoYXJBdChlbmM0KX1gO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBvdXRwdXQgKz0gYCR7dGVtcGxhdGUuY2hhckF0KGVuYzEpfSR7dGVtcGxhdGUuY2hhckF0KGVuYzIpfSR7dGVtcGxhdGUuY2hhckF0KGVuYzMpfSR7dGVtcGxhdGUuY2hhckF0KGVuYzQpfWA7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG91dHB1dDtcclxufVxyXG5mdW5jdGlvbiBmcm9tQmFzZTY0KGlucHV0LCB1c2VVcmxUZW1wbGF0ZSA9IGZhbHNlLCBjdXRUYWlsWmVyb3MgPSBmYWxzZSkge1xyXG4gICAgY29uc3QgdGVtcGxhdGUgPSAodXNlVXJsVGVtcGxhdGUpID8gYmFzZTY0VXJsVGVtcGxhdGUgOiBiYXNlNjRUZW1wbGF0ZTtcclxuICAgIGZ1bmN0aW9uIGluZGV4T2YodG9TZWFyY2gpIHtcclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdChpKSA9PT0gdG9TZWFyY2gpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIDY0O1xyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gdGVzdChpbmNvbWluZykge1xyXG4gICAgICAgIHJldHVybiAoKGluY29taW5nID09PSA2NCkgPyAweDAwIDogaW5jb21pbmcpO1xyXG4gICAgfVxyXG4gICAgbGV0IGkgPSAwO1xyXG4gICAgbGV0IG91dHB1dCA9IFwiXCI7XHJcbiAgICB3aGlsZSAoaSA8IGlucHV0Lmxlbmd0aCkge1xyXG4gICAgICAgIGNvbnN0IGVuYzEgPSBpbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcclxuICAgICAgICBjb25zdCBlbmMyID0gKGkgPj0gaW5wdXQubGVuZ3RoKSA/IDB4MDAgOiBpbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcclxuICAgICAgICBjb25zdCBlbmMzID0gKGkgPj0gaW5wdXQubGVuZ3RoKSA/IDB4MDAgOiBpbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcclxuICAgICAgICBjb25zdCBlbmM0ID0gKGkgPj0gaW5wdXQubGVuZ3RoKSA/IDB4MDAgOiBpbmRleE9mKGlucHV0LmNoYXJBdChpKyspKTtcclxuICAgICAgICBjb25zdCBjaHIxID0gKHRlc3QoZW5jMSkgPDwgMikgfCAodGVzdChlbmMyKSA+PiA0KTtcclxuICAgICAgICBjb25zdCBjaHIyID0gKCh0ZXN0KGVuYzIpICYgMHgwRikgPDwgNCkgfCAodGVzdChlbmMzKSA+PiAyKTtcclxuICAgICAgICBjb25zdCBjaHIzID0gKCh0ZXN0KGVuYzMpICYgMHgwMykgPDwgNikgfCB0ZXN0KGVuYzQpO1xyXG4gICAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjEpO1xyXG4gICAgICAgIGlmIChlbmMzICE9PSA2NCkge1xyXG4gICAgICAgICAgICBvdXRwdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaHIyKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVuYzQgIT09IDY0KSB7XHJcbiAgICAgICAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNocjMpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGlmIChjdXRUYWlsWmVyb3MpIHtcclxuICAgICAgICBjb25zdCBvdXRwdXRMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xyXG4gICAgICAgIGxldCBub25aZXJvU3RhcnQgPSAoLTEpO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAob3V0cHV0TGVuZ3RoIC0gMSk7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgICAgICAgIGlmIChvdXRwdXQuY2hhckNvZGVBdChpKSAhPT0gMCkge1xyXG4gICAgICAgICAgICAgICAgbm9uWmVyb1N0YXJ0ID0gaTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChub25aZXJvU3RhcnQgIT09ICgtMSkpIHtcclxuICAgICAgICAgICAgb3V0cHV0ID0gb3V0cHV0LnNsaWNlKDAsIG5vblplcm9TdGFydCArIDEpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgb3V0cHV0ID0gXCJcIjtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb3V0cHV0O1xyXG59XHJcbmZ1bmN0aW9uIGFycmF5QnVmZmVyVG9TdHJpbmcoYnVmZmVyKSB7XHJcbiAgICBsZXQgcmVzdWx0U3RyaW5nID0gXCJcIjtcclxuICAgIGNvbnN0IHZpZXcgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xyXG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHZpZXcpIHtcclxuICAgICAgICByZXN1bHRTdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShlbGVtZW50KTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHRTdHJpbmc7XHJcbn1cclxuZnVuY3Rpb24gc3RyaW5nVG9BcnJheUJ1ZmZlcihzdHIpIHtcclxuICAgIGNvbnN0IHN0cmluZ0xlbmd0aCA9IHN0ci5sZW5ndGg7XHJcbiAgICBjb25zdCByZXN1bHRCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoc3RyaW5nTGVuZ3RoKTtcclxuICAgIGNvbnN0IHJlc3VsdFZpZXcgPSBuZXcgVWludDhBcnJheShyZXN1bHRCdWZmZXIpO1xyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHJpbmdMZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHJlc3VsdFZpZXdbaV0gPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHRCdWZmZXI7XHJcbn1cclxuY29uc3QgbG9nMiA9IE1hdGgubG9nKDIpO1xyXG5mdW5jdGlvbiBuZWFyZXN0UG93ZXJPZjIobGVuZ3RoKSB7XHJcbiAgICBjb25zdCBiYXNlID0gKE1hdGgubG9nKGxlbmd0aCkgLyBsb2cyKTtcclxuICAgIGNvbnN0IGZsb29yID0gTWF0aC5mbG9vcihiYXNlKTtcclxuICAgIGNvbnN0IHJvdW5kID0gTWF0aC5yb3VuZChiYXNlKTtcclxuICAgIHJldHVybiAoKGZsb29yID09PSByb3VuZCkgPyBmbG9vciA6IHJvdW5kKTtcclxufVxyXG5mdW5jdGlvbiBjbGVhclByb3BzKG9iamVjdCwgcHJvcHNBcnJheSkge1xyXG4gICAgZm9yIChjb25zdCBwcm9wIG9mIHByb3BzQXJyYXkpIHtcclxuICAgICAgICBkZWxldGUgb2JqZWN0W3Byb3BdO1xyXG4gICAgfVxyXG59XG5cbmV4cG9ydCB7IGFycmF5QnVmZmVyVG9TdHJpbmcsIGJ1ZmZlclRvSGV4Q29kZXMsIGNoZWNrQnVmZmVyUGFyYW1zLCBjbGVhclByb3BzLCBmcm9tQmFzZTY0LCBnZXRQYXJhbWV0ZXJzVmFsdWUsIGdldFVUQ0RhdGUsIGlzRXF1YWxCdWZmZXIsIG5lYXJlc3RQb3dlck9mMiwgcGFkTnVtYmVyLCBzdHJpbmdUb0FycmF5QnVmZmVyLCB0b0Jhc2U2NCwgdXRpbENvbmNhdEJ1ZiwgdXRpbENvbmNhdFZpZXcsIHV0aWxEZWNvZGVUQywgdXRpbEVuY29kZVRDLCB1dGlsRnJvbUJhc2UsIHV0aWxUb0Jhc2UgfTtcbiJdLCJuYW1lcyI6WyJnZXRVVENEYXRlIiwiZGF0ZSIsIkRhdGUiLCJnZXRUaW1lIiwiZ2V0VGltZXpvbmVPZmZzZXQiLCJnZXRQYXJhbWV0ZXJzVmFsdWUiLCJwYXJhbWV0ZXJzIiwibmFtZSIsImRlZmF1bHRWYWx1ZSIsIl9hIiwiT2JqZWN0IiwiYnVmZmVyVG9IZXhDb2RlcyIsImlucHV0QnVmZmVyIiwiaW5wdXRPZmZzZXQiLCJpbnB1dExlbmd0aCIsImJ5dGVMZW5ndGgiLCJpbnNlcnRTcGFjZSIsInJlc3VsdCIsIml0ZW0iLCJVaW50OEFycmF5Iiwic3RyIiwidG9TdHJpbmciLCJ0b1VwcGVyQ2FzZSIsImxlbmd0aCIsInRyaW0iLCJjaGVja0J1ZmZlclBhcmFtcyIsImJhc2VCbG9jayIsIkFycmF5QnVmZmVyIiwiZXJyb3IiLCJ1dGlsRnJvbUJhc2UiLCJpbnB1dEJhc2UiLCJpIiwiTWF0aCIsInBvdyIsInV0aWxUb0Jhc2UiLCJ2YWx1ZSIsImJhc2UiLCJyZXNlcnZlZCIsImludGVybmFsUmVzZXJ2ZWQiLCJpbnRlcm5hbFZhbHVlIiwiYmlnZ2VzdCIsInJldEJ1ZiIsInJldFZpZXciLCJqIiwiYmFzaXMiLCJmbG9vciIsInV0aWxDb25jYXRCdWYiLCJidWZmZXJzIiwib3V0cHV0TGVuZ3RoIiwicHJldkxlbmd0aCIsImJ1ZmZlciIsInNldCIsInV0aWxDb25jYXRWaWV3Iiwidmlld3MiLCJ2aWV3IiwidXRpbERlY29kZVRDIiwiYnVmIiwidmFsdWVIZXgiLCJjb25kaXRpb24xIiwiY29uZGl0aW9uMiIsIndhcm5pbmdzIiwicHVzaCIsImJpZ0ludEJ1ZmZlciIsImJpZ0ludFZpZXciLCJiaWdJbnQiLCJzbWFsbEludEJ1ZmZlciIsInNtYWxsSW50VmlldyIsInNtYWxsSW50IiwidXRpbEVuY29kZVRDIiwibW9kVmFsdWUiLCJ0ZW1wQnVmIiwic2xpY2UiLCJ0ZW1wVmlldyIsImsiLCJpc0VxdWFsQnVmZmVyIiwiaW5wdXRCdWZmZXIxIiwiaW5wdXRCdWZmZXIyIiwidmlldzEiLCJ2aWV3MiIsInBhZE51bWJlciIsImlucHV0TnVtYmVyIiwiZnVsbExlbmd0aCIsImRpZiIsInBhZGRpbmciLCJBcnJheSIsInBhZGRpbmdTdHJpbmciLCJqb2luIiwiY29uY2F0IiwiYmFzZTY0VGVtcGxhdGUiLCJiYXNlNjRVcmxUZW1wbGF0ZSIsInRvQmFzZTY0IiwiaW5wdXQiLCJ1c2VVcmxUZW1wbGF0ZSIsInNraXBQYWRkaW5nIiwic2tpcExlYWRpbmdaZXJvcyIsImZsYWcxIiwiZmxhZzIiLCJvdXRwdXQiLCJ0ZW1wbGF0ZSIsIm5vblplcm9Qb3NpdGlvbiIsImNoYXJDb2RlQXQiLCJjaHIxIiwiY2hyMiIsImNocjMiLCJlbmMxIiwiZW5jMiIsImVuYzMiLCJlbmM0IiwiY2hhckF0IiwiZnJvbUJhc2U2NCIsImN1dFRhaWxaZXJvcyIsImluZGV4T2YiLCJ0b1NlYXJjaCIsInRlc3QiLCJpbmNvbWluZyIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIm5vblplcm9TdGFydCIsImFycmF5QnVmZmVyVG9TdHJpbmciLCJyZXN1bHRTdHJpbmciLCJlbGVtZW50Iiwic3RyaW5nVG9BcnJheUJ1ZmZlciIsInN0cmluZ0xlbmd0aCIsInJlc3VsdEJ1ZmZlciIsInJlc3VsdFZpZXciLCJsb2cyIiwibG9nIiwibmVhcmVzdFBvd2VyT2YyIiwicm91bmQiLCJjbGVhclByb3BzIiwib2JqZWN0IiwicHJvcHNBcnJheSIsInByb3AiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/pvutils/build/utils.es.js\n");

/***/ })

};
;