"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/swr";
exports.ids = ["vendor-chunks/swr"];
exports.modules = {

/***/ "(ssr)/./node_modules/swr/_internal/dist/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/swr/_internal/dist/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IS_REACT_LEGACY: () => (/* binding */ IS_REACT_LEGACY),\n/* harmony export */   IS_SERVER: () => (/* binding */ IS_SERVER),\n/* harmony export */   OBJECT: () => (/* binding */ OBJECT),\n/* harmony export */   SWRConfig: () => (/* binding */ SWRConfig),\n/* harmony export */   SWRGlobalState: () => (/* binding */ SWRGlobalState),\n/* harmony export */   UNDEFINED: () => (/* binding */ UNDEFINED),\n/* harmony export */   cache: () => (/* binding */ cache),\n/* harmony export */   compare: () => (/* binding */ compare),\n/* harmony export */   createCacheHelper: () => (/* binding */ createCacheHelper),\n/* harmony export */   defaultConfig: () => (/* binding */ defaultConfig),\n/* harmony export */   defaultConfigOptions: () => (/* binding */ defaultConfigOptions),\n/* harmony export */   getTimestamp: () => (/* binding */ getTimestamp),\n/* harmony export */   hasRequestAnimationFrame: () => (/* binding */ hasRequestAnimationFrame),\n/* harmony export */   initCache: () => (/* binding */ initCache),\n/* harmony export */   internalMutate: () => (/* binding */ internalMutate),\n/* harmony export */   isDocumentDefined: () => (/* binding */ isDocumentDefined),\n/* harmony export */   isFunction: () => (/* binding */ isFunction),\n/* harmony export */   isPromiseLike: () => (/* binding */ isPromiseLike),\n/* harmony export */   isUndefined: () => (/* binding */ isUndefined),\n/* harmony export */   isWindowDefined: () => (/* binding */ isWindowDefined),\n/* harmony export */   mergeConfigs: () => (/* binding */ mergeConfigs),\n/* harmony export */   mergeObjects: () => (/* binding */ mergeObjects),\n/* harmony export */   mutate: () => (/* binding */ mutate),\n/* harmony export */   noop: () => (/* binding */ noop),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   preload: () => (/* binding */ preload),\n/* harmony export */   preset: () => (/* binding */ preset),\n/* harmony export */   rAF: () => (/* binding */ rAF),\n/* harmony export */   revalidateEvents: () => (/* binding */ constants),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   slowConnection: () => (/* binding */ slowConnection),\n/* harmony export */   stableHash: () => (/* binding */ stableHash),\n/* harmony export */   subscribeCallback: () => (/* binding */ subscribeCallback),\n/* harmony export */   useIsomorphicLayoutEffect: () => (/* binding */ useIsomorphicLayoutEffect),\n/* harmony export */   useSWRConfig: () => (/* binding */ useSWRConfig),\n/* harmony export */   useStateWithDeps: () => (/* binding */ useStateWithDeps),\n/* harmony export */   withArgs: () => (/* binding */ withArgs),\n/* harmony export */   withMiddleware: () => (/* binding */ withMiddleware)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n// Shared state between server components and client components\nconst noop = ()=>{};\n// Using noop() as the undefined value as undefined can be replaced\n// by something else. Prettier ignore and extra parentheses are necessary here\n// to ensure that tsc doesn't remove the __NOINLINE__ comment.\n// prettier-ignore\nconst UNDEFINED = /*#__NOINLINE__*/ noop();\nconst OBJECT = Object;\nconst isUndefined = (v)=>v === UNDEFINED;\nconst isFunction = (v)=>typeof v == \"function\";\nconst mergeObjects = (a, b)=>({\n        ...a,\n        ...b\n    });\nconst isPromiseLike = (x)=>isFunction(x.then);\n// use WeakMap to store the object->key mapping\n// so the objects can be garbage collected.\n// WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\nconst table = new WeakMap();\n// counter of the key\nlet counter = 0;\n// A stable hash implementation that supports:\n// - Fast and ensures unique hash properties\n// - Handles unserializable values\n// - Handles object key ordering\n// - Generates short results\n//\n// This is not a serialization function, and the result is not guaranteed to be\n// parsable.\nconst stableHash = (arg)=>{\n    const type = typeof arg;\n    const constructor = arg && arg.constructor;\n    const isDate = constructor == Date;\n    let result;\n    let index;\n    if (OBJECT(arg) === arg && !isDate && constructor != RegExp) {\n        // Object/function, not null/date/regexp. Use WeakMap to store the id first.\n        // If it's already hashed, directly return the result.\n        result = table.get(arg);\n        if (result) return result;\n        // Store the hash first for circular reference detection before entering the\n        // recursive `stableHash` calls.\n        // For other objects like set and map, we use this id directly as the hash.\n        result = ++counter + \"~\";\n        table.set(arg, result);\n        if (constructor == Array) {\n            // Array.\n            result = \"@\";\n            for(index = 0; index < arg.length; index++){\n                result += stableHash(arg[index]) + \",\";\n            }\n            table.set(arg, result);\n        }\n        if (constructor == OBJECT) {\n            // Object, sort keys.\n            result = \"#\";\n            const keys = OBJECT.keys(arg).sort();\n            while(!isUndefined(index = keys.pop())){\n                if (!isUndefined(arg[index])) {\n                    result += index + \":\" + stableHash(arg[index]) + \",\";\n                }\n            }\n            table.set(arg, result);\n        }\n    } else {\n        result = isDate ? arg.toJSON() : type == \"symbol\" ? arg.toString() : type == \"string\" ? JSON.stringify(arg) : \"\" + arg;\n    }\n    return result;\n};\n// Global state used to deduplicate requests and store listeners\nconst SWRGlobalState = new WeakMap();\nconst EMPTY_CACHE = {};\nconst INITIAL_CACHE = {};\nconst STR_UNDEFINED = \"undefined\";\n// NOTE: Use the function to guarantee it's re-evaluated between jsdom and node runtime for tests.\nconst isWindowDefined = \"undefined\" != STR_UNDEFINED;\nconst isDocumentDefined = typeof document != STR_UNDEFINED;\nconst hasRequestAnimationFrame = ()=>isWindowDefined && typeof window[\"requestAnimationFrame\"] != STR_UNDEFINED;\nconst createCacheHelper = (cache, key)=>{\n    const state = SWRGlobalState.get(cache);\n    return [\n        // Getter\n        ()=>!isUndefined(key) && cache.get(key) || EMPTY_CACHE,\n        // Setter\n        (info)=>{\n            if (!isUndefined(key)) {\n                const prev = cache.get(key);\n                // Before writing to the store, we keep the value in the initial cache\n                // if it's not there yet.\n                if (!(key in INITIAL_CACHE)) {\n                    INITIAL_CACHE[key] = prev;\n                }\n                state[5](key, mergeObjects(prev, info), prev || EMPTY_CACHE);\n            }\n        },\n        // Subscriber\n        state[6],\n        // Get server cache snapshot\n        ()=>{\n            if (!isUndefined(key)) {\n                // If the cache was updated on the client, we return the stored initial value.\n                if (key in INITIAL_CACHE) return INITIAL_CACHE[key];\n            }\n            // If we haven't done any client-side updates, we return the current value.\n            return !isUndefined(key) && cache.get(key) || EMPTY_CACHE;\n        }\n    ];\n} // export { UNDEFINED, OBJECT, isUndefined, isFunction, mergeObjects, isPromiseLike }\n;\n/**\n * Due to the bug https://bugs.chromium.org/p/chromium/issues/detail?id=678075,\n * it's not reliable to detect if the browser is currently online or offline\n * based on `navigator.onLine`.\n * As a workaround, we always assume it's online on the first load, and change\n * the status upon `online` or `offline` events.\n */ let online = true;\nconst isOnline = ()=>online;\n// For node and React Native, `add/removeEventListener` doesn't exist on window.\nconst [onWindowEvent, offWindowEvent] = isWindowDefined && window.addEventListener ? [\n    window.addEventListener.bind(window),\n    window.removeEventListener.bind(window)\n] : [\n    noop,\n    noop\n];\nconst isVisible = ()=>{\n    const visibilityState = isDocumentDefined && document.visibilityState;\n    return isUndefined(visibilityState) || visibilityState !== \"hidden\";\n};\nconst initFocus = (callback)=>{\n    // focus revalidate\n    if (isDocumentDefined) {\n        document.addEventListener(\"visibilitychange\", callback);\n    }\n    onWindowEvent(\"focus\", callback);\n    return ()=>{\n        if (isDocumentDefined) {\n            document.removeEventListener(\"visibilitychange\", callback);\n        }\n        offWindowEvent(\"focus\", callback);\n    };\n};\nconst initReconnect = (callback)=>{\n    // revalidate on reconnected\n    const onOnline = ()=>{\n        online = true;\n        callback();\n    };\n    // nothing to revalidate, just update the status\n    const onOffline = ()=>{\n        online = false;\n    };\n    onWindowEvent(\"online\", onOnline);\n    onWindowEvent(\"offline\", onOffline);\n    return ()=>{\n        offWindowEvent(\"online\", onOnline);\n        offWindowEvent(\"offline\", onOffline);\n    };\n};\nconst preset = {\n    isOnline,\n    isVisible\n};\nconst defaultConfigOptions = {\n    initFocus,\n    initReconnect\n};\nconst IS_REACT_LEGACY = !(react__WEBPACK_IMPORTED_MODULE_0___default().useId);\nconst IS_SERVER = !isWindowDefined || \"Deno\" in window;\n// Polyfill requestAnimationFrame\nconst rAF = (f)=>hasRequestAnimationFrame() ? window[\"requestAnimationFrame\"](f) : setTimeout(f, 1);\n// React currently throws a warning when using useLayoutEffect on the server.\n// To get around it, we can conditionally useEffect on the server (no-op) and\n// useLayoutEffect in the browser.\nconst useIsomorphicLayoutEffect = IS_SERVER ? react__WEBPACK_IMPORTED_MODULE_0__.useEffect : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;\n// This assignment is to extend the Navigator type to use effectiveType.\nconst navigatorConnection = typeof navigator !== \"undefined\" && navigator.connection;\n// Adjust the config based on slow connection status (<= 70Kbps).\nconst slowConnection = !IS_SERVER && navigatorConnection && ([\n    \"slow-2g\",\n    \"2g\"\n].includes(navigatorConnection.effectiveType) || navigatorConnection.saveData);\nconst serialize = (key)=>{\n    if (isFunction(key)) {\n        try {\n            key = key();\n        } catch (err) {\n            // dependencies not ready\n            key = \"\";\n        }\n    }\n    // Use the original key as the argument of fetcher. This can be a string or an\n    // array of values.\n    const args = key;\n    // If key is not falsy, or not an empty array, hash it.\n    key = typeof key == \"string\" ? key : (Array.isArray(key) ? key.length : key) ? stableHash(key) : \"\";\n    return [\n        key,\n        args\n    ];\n};\n// Global timestamp.\nlet __timestamp = 0;\nconst getTimestamp = ()=>++__timestamp;\nconst FOCUS_EVENT = 0;\nconst RECONNECT_EVENT = 1;\nconst MUTATE_EVENT = 2;\nconst ERROR_REVALIDATE_EVENT = 3;\nvar constants = {\n    __proto__: null,\n    ERROR_REVALIDATE_EVENT: ERROR_REVALIDATE_EVENT,\n    FOCUS_EVENT: FOCUS_EVENT,\n    MUTATE_EVENT: MUTATE_EVENT,\n    RECONNECT_EVENT: RECONNECT_EVENT\n};\nasync function internalMutate(...args) {\n    const [cache, _key, _data, _opts] = args;\n    // When passing as a boolean, it's explicitly used to disable/enable\n    // revalidation.\n    const options = mergeObjects({\n        populateCache: true,\n        throwOnError: true\n    }, typeof _opts === \"boolean\" ? {\n        revalidate: _opts\n    } : _opts || {});\n    let populateCache = options.populateCache;\n    const rollbackOnErrorOption = options.rollbackOnError;\n    let optimisticData = options.optimisticData;\n    const revalidate = options.revalidate !== false;\n    const rollbackOnError = (error)=>{\n        return typeof rollbackOnErrorOption === \"function\" ? rollbackOnErrorOption(error) : rollbackOnErrorOption !== false;\n    };\n    const throwOnError = options.throwOnError;\n    // If the second argument is a key filter, return the mutation results for all\n    // filtered keys.\n    if (isFunction(_key)) {\n        const keyFilter = _key;\n        const matchedKeys = [];\n        const it = cache.keys();\n        for (const key of it){\n            if (!/^\\$(inf|sub)\\$/.test(key) && keyFilter(cache.get(key)._k)) {\n                matchedKeys.push(key);\n            }\n        }\n        return Promise.all(matchedKeys.map(mutateByKey));\n    }\n    return mutateByKey(_key);\n    async function mutateByKey(_k) {\n        // Serialize key\n        const [key] = serialize(_k);\n        if (!key) return;\n        const [get, set] = createCacheHelper(cache, key);\n        const [EVENT_REVALIDATORS, MUTATION, FETCH, PRELOAD] = SWRGlobalState.get(cache);\n        const revalidators = EVENT_REVALIDATORS[key];\n        const startRevalidate = ()=>{\n            if (revalidate) {\n                // Invalidate the key by deleting the concurrent request markers so new\n                // requests will not be deduped.\n                delete FETCH[key];\n                delete PRELOAD[key];\n                if (revalidators && revalidators[0]) {\n                    return revalidators[0](MUTATE_EVENT).then(()=>get().data);\n                }\n            }\n            return get().data;\n        };\n        // If there is no new data provided, revalidate the key with current state.\n        if (args.length < 3) {\n            // Revalidate and broadcast state.\n            return startRevalidate();\n        }\n        let data = _data;\n        let error;\n        // Update global timestamps.\n        const beforeMutationTs = getTimestamp();\n        MUTATION[key] = [\n            beforeMutationTs,\n            0\n        ];\n        const hasOptimisticData = !isUndefined(optimisticData);\n        const state = get();\n        // `displayedData` is the current value on screen. It could be the optimistic value\n        // that is going to be overridden by a `committedData`, or get reverted back.\n        // `committedData` is the validated value that comes from a fetch or mutation.\n        const displayedData = state.data;\n        const currentData = state._c;\n        const committedData = isUndefined(currentData) ? displayedData : currentData;\n        // Do optimistic data update.\n        if (hasOptimisticData) {\n            optimisticData = isFunction(optimisticData) ? optimisticData(committedData, displayedData) : optimisticData;\n            // When we set optimistic data, backup the current committedData data in `_c`.\n            set({\n                data: optimisticData,\n                _c: committedData\n            });\n        }\n        if (isFunction(data)) {\n            // `data` is a function, call it passing current cache value.\n            try {\n                data = data(committedData);\n            } catch (err) {\n                // If it throws an error synchronously, we shouldn't update the cache.\n                error = err;\n            }\n        }\n        // `data` is a promise/thenable, resolve the final data first.\n        if (data && isPromiseLike(data)) {\n            // This means that the mutation is async, we need to check timestamps to\n            // avoid race conditions.\n            data = await data.catch((err)=>{\n                error = err;\n            });\n            // Check if other mutations have occurred since we've started this mutation.\n            // If there's a race we don't update cache or broadcast the change,\n            // just return the data.\n            if (beforeMutationTs !== MUTATION[key][0]) {\n                if (error) throw error;\n                return data;\n            } else if (error && hasOptimisticData && rollbackOnError(error)) {\n                // Rollback. Always populate the cache in this case but without\n                // transforming the data.\n                populateCache = true;\n                data = committedData;\n                // Reset data to be the latest committed data, and clear the `_c` value.\n                set({\n                    data,\n                    _c: UNDEFINED\n                });\n            }\n        }\n        // If we should write back the cache after request.\n        if (populateCache) {\n            if (!error) {\n                // Transform the result into data.\n                if (isFunction(populateCache)) {\n                    data = populateCache(data, committedData);\n                }\n                // Only update cached data and reset the error if there's no error. Data can be `undefined` here.\n                set({\n                    data,\n                    error: UNDEFINED,\n                    _c: UNDEFINED\n                });\n            }\n        }\n        // Reset the timestamp to mark the mutation has ended.\n        MUTATION[key][1] = getTimestamp();\n        // Update existing SWR Hooks' internal states:\n        const res = await startRevalidate();\n        // The mutation and revalidation are ended, we can clear it since the data is\n        // not an optimistic value anymore.\n        set({\n            _c: UNDEFINED\n        });\n        // Throw error or return data\n        if (error) {\n            if (throwOnError) throw error;\n            return;\n        }\n        return populateCache ? res : data;\n    }\n}\nconst revalidateAllKeys = (revalidators, type)=>{\n    for(const key in revalidators){\n        if (revalidators[key][0]) revalidators[key][0](type);\n    }\n};\nconst initCache = (provider, options)=>{\n    // The global state for a specific provider will be used to deduplicate\n    // requests and store listeners. As well as a mutate function that is bound to\n    // the cache.\n    // The provider's global state might be already initialized. Let's try to get the\n    // global state associated with the provider first.\n    if (!SWRGlobalState.has(provider)) {\n        const opts = mergeObjects(defaultConfigOptions, options);\n        // If there's no global state bound to the provider, create a new one with the\n        // new mutate function.\n        const EVENT_REVALIDATORS = {};\n        const mutate = internalMutate.bind(UNDEFINED, provider);\n        let unmount = noop;\n        const subscriptions = {};\n        const subscribe = (key, callback)=>{\n            const subs = subscriptions[key] || [];\n            subscriptions[key] = subs;\n            subs.push(callback);\n            return ()=>subs.splice(subs.indexOf(callback), 1);\n        };\n        const setter = (key, value, prev)=>{\n            provider.set(key, value);\n            const subs = subscriptions[key];\n            if (subs) {\n                for (const fn of subs){\n                    fn(value, prev);\n                }\n            }\n        };\n        const initProvider = ()=>{\n            if (!SWRGlobalState.has(provider)) {\n                // Update the state if it's new, or if the provider has been extended.\n                SWRGlobalState.set(provider, [\n                    EVENT_REVALIDATORS,\n                    {},\n                    {},\n                    {},\n                    mutate,\n                    setter,\n                    subscribe\n                ]);\n                if (!IS_SERVER) {\n                    // When listening to the native events for auto revalidations,\n                    // we intentionally put a delay (setTimeout) here to make sure they are\n                    // fired after immediate JavaScript executions, which can be\n                    // React's state updates.\n                    // This avoids some unnecessary revalidations such as\n                    // https://github.com/vercel/swr/issues/1680.\n                    const releaseFocus = opts.initFocus(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, FOCUS_EVENT)));\n                    const releaseReconnect = opts.initReconnect(setTimeout.bind(UNDEFINED, revalidateAllKeys.bind(UNDEFINED, EVENT_REVALIDATORS, RECONNECT_EVENT)));\n                    unmount = ()=>{\n                        releaseFocus && releaseFocus();\n                        releaseReconnect && releaseReconnect();\n                        // When un-mounting, we need to remove the cache provider from the state\n                        // storage too because it's a side-effect. Otherwise, when re-mounting we\n                        // will not re-register those event listeners.\n                        SWRGlobalState.delete(provider);\n                    };\n                }\n            }\n        };\n        initProvider();\n        // This is a new provider, we need to initialize it and setup DOM events\n        // listeners for `focus` and `reconnect` actions.\n        // We might want to inject an extra layer on top of `provider` in the future,\n        // such as key serialization, auto GC, etc.\n        // For now, it's just a `Map` interface without any modifications.\n        return [\n            provider,\n            mutate,\n            initProvider,\n            unmount\n        ];\n    }\n    return [\n        provider,\n        SWRGlobalState.get(provider)[4]\n    ];\n};\n// error retry\nconst onErrorRetry = (_, __, config, revalidate, opts)=>{\n    const maxRetryCount = config.errorRetryCount;\n    const currentRetryCount = opts.retryCount;\n    // Exponential backoff\n    const timeout = ~~((Math.random() + 0.5) * (1 << (currentRetryCount < 8 ? currentRetryCount : 8))) * config.errorRetryInterval;\n    if (!isUndefined(maxRetryCount) && currentRetryCount > maxRetryCount) {\n        return;\n    }\n    setTimeout(revalidate, timeout, opts);\n};\nconst compare = (currentData, newData)=>stableHash(currentData) == stableHash(newData);\n// Default cache provider\nconst [cache, mutate] = initCache(new Map());\n// Default config\nconst defaultConfig = mergeObjects({\n    // events\n    onLoadingSlow: noop,\n    onSuccess: noop,\n    onError: noop,\n    onErrorRetry,\n    onDiscarded: noop,\n    // switches\n    revalidateOnFocus: true,\n    revalidateOnReconnect: true,\n    revalidateIfStale: true,\n    shouldRetryOnError: true,\n    // timeouts\n    errorRetryInterval: slowConnection ? 10000 : 5000,\n    focusThrottleInterval: 5 * 1000,\n    dedupingInterval: 2 * 1000,\n    loadingTimeout: slowConnection ? 5000 : 3000,\n    // providers\n    compare,\n    isPaused: ()=>false,\n    cache,\n    mutate,\n    fallback: {}\n}, preset);\nconst mergeConfigs = (a, b)=>{\n    // Need to create a new object to avoid mutating the original here.\n    const v = mergeObjects(a, b);\n    // If two configs are provided, merge their `use` and `fallback` options.\n    if (b) {\n        const { use: u1, fallback: f1 } = a;\n        const { use: u2, fallback: f2 } = b;\n        if (u1 && u2) {\n            v.use = u1.concat(u2);\n        }\n        if (f1 && f2) {\n            v.fallback = mergeObjects(f1, f2);\n        }\n    }\n    return v;\n};\nconst SWRConfigContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nconst SWRConfig = (props)=>{\n    const { value } = props;\n    const parentConfig = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SWRConfigContext);\n    const isFunctionalConfig = isFunction(value);\n    const config = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>isFunctionalConfig ? value(parentConfig) : value, [\n        isFunctionalConfig,\n        parentConfig,\n        value\n    ]);\n    // Extend parent context values and middleware.\n    const extendedConfig = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>isFunctionalConfig ? config : mergeConfigs(parentConfig, config), [\n        isFunctionalConfig,\n        parentConfig,\n        config\n    ]);\n    // Should not use the inherited provider.\n    const provider = config && config.provider;\n    // initialize the cache only on first access.\n    const cacheContextRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(UNDEFINED);\n    if (provider && !cacheContextRef.current) {\n        cacheContextRef.current = initCache(provider(extendedConfig.cache || cache), config);\n    }\n    const cacheContext = cacheContextRef.current;\n    // Override the cache if a new provider is given.\n    if (cacheContext) {\n        extendedConfig.cache = cacheContext[0];\n        extendedConfig.mutate = cacheContext[1];\n    }\n    // Unsubscribe events.\n    useIsomorphicLayoutEffect(()=>{\n        if (cacheContext) {\n            cacheContext[2] && cacheContext[2]();\n            return cacheContext[3];\n        }\n    }, []);\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(SWRConfigContext.Provider, mergeObjects(props, {\n        value: extendedConfig\n    }));\n};\n// @ts-expect-error\nconst enableDevtools = isWindowDefined && window.__SWR_DEVTOOLS_USE__;\nconst use = enableDevtools ? window.__SWR_DEVTOOLS_USE__ : [];\nconst setupDevTools = ()=>{\n    if (enableDevtools) {\n        // @ts-expect-error\n        window.__SWR_DEVTOOLS_REACT__ = (react__WEBPACK_IMPORTED_MODULE_0___default());\n    }\n};\nconst normalize = (args)=>{\n    return isFunction(args[1]) ? [\n        args[0],\n        args[1],\n        args[2] || {}\n    ] : [\n        args[0],\n        null,\n        (args[1] === null ? args[2] : args[1]) || {}\n    ];\n};\nconst useSWRConfig = ()=>{\n    return mergeObjects(defaultConfig, (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(SWRConfigContext));\n};\nconst preload = (key_, fetcher)=>{\n    const [key, fnArg] = serialize(key_);\n    const [, , , PRELOAD] = SWRGlobalState.get(cache);\n    // Prevent preload to be called multiple times before used.\n    if (PRELOAD[key]) return PRELOAD[key];\n    const req = fetcher(fnArg);\n    PRELOAD[key] = req;\n    return req;\n};\nconst middleware = (useSWRNext)=>(key_, fetcher_, config)=>{\n        // fetcher might be a sync function, so this should not be an async function\n        const fetcher = fetcher_ && ((...args)=>{\n            const [key] = serialize(key_);\n            const [, , , PRELOAD] = SWRGlobalState.get(cache);\n            const req = PRELOAD[key];\n            if (isUndefined(req)) return fetcher_(...args);\n            delete PRELOAD[key];\n            return req;\n        });\n        return useSWRNext(key_, fetcher, config);\n    };\nconst BUILT_IN_MIDDLEWARE = use.concat(middleware);\n// It's tricky to pass generic types as parameters, so we just directly override\n// the types here.\nconst withArgs = (hook)=>{\n    return function useSWRArgs(...args) {\n        // Get the default and inherited configuration.\n        const fallbackConfig = useSWRConfig();\n        // Normalize arguments.\n        const [key, fn, _config] = normalize(args);\n        // Merge configurations.\n        const config = mergeConfigs(fallbackConfig, _config);\n        // Apply middleware\n        let next = hook;\n        const { use } = config;\n        const middleware = (use || []).concat(BUILT_IN_MIDDLEWARE);\n        for(let i = middleware.length; i--;){\n            next = middleware[i](next);\n        }\n        return next(key, fn || config.fetcher || null, config);\n    };\n};\n/**\n * An implementation of state with dependency-tracking.\n */ const useStateWithDeps = (state)=>{\n    const rerender = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({})[1];\n    const unmountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const stateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(state);\n    // If a state property (data, error, or isValidating) is accessed by the render\n    // function, we mark the property as a dependency so if it is updated again\n    // in the future, we trigger a rerender.\n    // This is also known as dependency-tracking.\n    const stateDependenciesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n        data: false,\n        error: false,\n        isValidating: false\n    });\n    /**\n   * @param payload To change stateRef, pass the values explicitly to setState:\n   * @example\n   * ```js\n   * setState({\n   *   isValidating: false\n   *   data: newData // set data to newData\n   *   error: undefined // set error to undefined\n   * })\n   *\n   * setState({\n   *   isValidating: false\n   *   data: undefined // set data to undefined\n   *   error: err // set error to err\n   * })\n   * ```\n   */ const setState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((payload)=>{\n        let shouldRerender = false;\n        const currentState = stateRef.current;\n        for(const _ in payload){\n            const k = _;\n            // If the property has changed, update the state and mark rerender as\n            // needed.\n            if (currentState[k] !== payload[k]) {\n                currentState[k] = payload[k];\n                // If the property is accessed by the component, a rerender should be\n                // triggered.\n                if (stateDependenciesRef.current[k]) {\n                    shouldRerender = true;\n                }\n            }\n        }\n        if (shouldRerender && !unmountedRef.current) {\n            if (IS_REACT_LEGACY) {\n                rerender({});\n            } else {\n                react__WEBPACK_IMPORTED_MODULE_0___default().startTransition(()=>rerender({}));\n            }\n        }\n    }, [\n        rerender\n    ]);\n    useIsomorphicLayoutEffect(()=>{\n        unmountedRef.current = false;\n        return ()=>{\n            unmountedRef.current = true;\n        };\n    });\n    return [\n        stateRef,\n        stateDependenciesRef.current,\n        setState\n    ];\n};\n// Add a callback function to a list of keyed callback functions and return\n// the unsubscribe function.\nconst subscribeCallback = (key, callbacks, callback)=>{\n    const keyedRevalidators = callbacks[key] || (callbacks[key] = []);\n    keyedRevalidators.push(callback);\n    return ()=>{\n        const index = keyedRevalidators.indexOf(callback);\n        if (index >= 0) {\n            // O(1): faster than splice\n            keyedRevalidators[index] = keyedRevalidators[keyedRevalidators.length - 1];\n            keyedRevalidators.pop();\n        }\n    };\n};\n// Create a custom hook with a middleware\nconst withMiddleware = (useSWR, middleware)=>{\n    return (...args)=>{\n        const [key, fn, config] = normalize(args);\n        const uses = (config.use || []).concat(middleware);\n        return useSWR(key, fn, {\n            ...config,\n            use: uses\n        });\n    };\n};\nsetupDevTools();\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dyL19pbnRlcm5hbC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRJO0FBRTVJLCtEQUErRDtBQUMvRCxNQUFNVSxPQUFPLEtBQUs7QUFDbEIsbUVBQW1FO0FBQ25FLDhFQUE4RTtBQUM5RSw4REFBOEQ7QUFDOUQsa0JBQWtCO0FBQ2xCLE1BQU1DLFlBQVksZUFBZSxHQUFHRDtBQUNwQyxNQUFNRSxTQUFTQztBQUNmLE1BQU1DLGNBQWMsQ0FBQ0MsSUFBSUEsTUFBTUo7QUFDL0IsTUFBTUssYUFBYSxDQUFDRCxJQUFJLE9BQU9BLEtBQUs7QUFDcEMsTUFBTUUsZUFBZSxDQUFDQyxHQUFHQyxJQUFLO1FBQ3RCLEdBQUdELENBQUM7UUFDSixHQUFHQyxDQUFDO0lBQ1I7QUFDSixNQUFNQyxnQkFBZ0IsQ0FBQ0MsSUFBSUwsV0FBV0ssRUFBRUMsSUFBSTtBQUU1QywrQ0FBK0M7QUFDL0MsMkNBQTJDO0FBQzNDLHlEQUF5RDtBQUN6RCw2QkFBNkI7QUFDN0IsTUFBTUMsUUFBUSxJQUFJQztBQUNsQixxQkFBcUI7QUFDckIsSUFBSUMsVUFBVTtBQUNkLDhDQUE4QztBQUM5Qyw0Q0FBNEM7QUFDNUMsa0NBQWtDO0FBQ2xDLGdDQUFnQztBQUNoQyw0QkFBNEI7QUFDNUIsRUFBRTtBQUNGLCtFQUErRTtBQUMvRSxZQUFZO0FBQ1osTUFBTUMsYUFBYSxDQUFDQztJQUNoQixNQUFNQyxPQUFPLE9BQU9EO0lBQ3BCLE1BQU1FLGNBQWNGLE9BQU9BLElBQUlFLFdBQVc7SUFDMUMsTUFBTUMsU0FBU0QsZUFBZUU7SUFDOUIsSUFBSUM7SUFDSixJQUFJQztJQUNKLElBQUlyQixPQUFPZSxTQUFTQSxPQUFPLENBQUNHLFVBQVVELGVBQWVLLFFBQVE7UUFDekQsNEVBQTRFO1FBQzVFLHNEQUFzRDtRQUN0REYsU0FBU1QsTUFBTVksR0FBRyxDQUFDUjtRQUNu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QWEzQixPQUFPLEdBQUc7UUFDdkIsT0FBTztZQUNIMkIsYUFBYTNCLE9BQU8sR0FBRztRQUMzQjtJQUNKO0lBQ0EsT0FBTztRQUNINEI7UUFDQUMscUJBQXFCN0IsT0FBTztRQUM1QitCO0tBQ0g7QUFDTDtBQUVBLDJFQUEyRTtBQUMzRSw0QkFBNEI7QUFDNUIsTUFBTU0sb0JBQW9CLENBQUN0TCxLQUFLdUwsV0FBV3pLO0lBQ3ZDLE1BQU0wSyxvQkFBb0JELFNBQVMsQ0FBQ3ZMLElBQUksSUFBS3VMLENBQUFBLFNBQVMsQ0FBQ3ZMLElBQUksR0FBRyxFQUFFO0lBQ2hFd0wsa0JBQWtCekgsSUFBSSxDQUFDakQ7SUFDdkIsT0FBTztRQUNILE1BQU10QyxRQUFRZ04sa0JBQWtCMUYsT0FBTyxDQUFDaEY7UUFDeEMsSUFBSXRDLFNBQVMsR0FBRztZQUNaLDJCQUEyQjtZQUMzQmdOLGlCQUFpQixDQUFDaE4sTUFBTSxHQUFHZ04saUJBQWlCLENBQUNBLGtCQUFrQjNNLE1BQU0sR0FBRyxFQUFFO1lBQzFFMk0sa0JBQWtCeE0sR0FBRztRQUN6QjtJQUNKO0FBQ0o7QUFFQSx5Q0FBeUM7QUFDekMsTUFBTXlNLGlCQUFpQixDQUFDQyxRQUFRM0I7SUFDNUIsT0FBTyxDQUFDLEdBQUczSDtRQUNQLE1BQU0sQ0FBQ3BDLEtBQUtpRyxJQUFJUSxPQUFPLEdBQUcrQyxVQUFVcEg7UUFDcEMsTUFBTXVKLE9BQU8sQ0FBQ2xGLE9BQU8yQixHQUFHLElBQUksRUFBRSxFQUFFSyxNQUFNLENBQUNzQjtRQUN2QyxPQUFPMkIsT0FBTzFMLEtBQUtpRyxJQUFJO1lBQ25CLEdBQUdRLE1BQU07WUFDVDJCLEtBQUt1RDtRQUNUO0lBQ0o7QUFDSjtBQUVBckM7QUFFb2lCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmlkZW8tc3RyZWFtaW5nLy4vbm9kZV9tb2R1bGVzL3N3ci9faW50ZXJuYWwvZGlzdC9pbmRleC5tanM/YTM2YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QsIGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZU1lbW8sIHVzZVJlZiwgY3JlYXRlRWxlbWVudCwgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuXG4vLyBTaGFyZWQgc3RhdGUgYmV0d2VlbiBzZXJ2ZXIgY29tcG9uZW50cyBhbmQgY2xpZW50IGNvbXBvbmVudHNcbmNvbnN0IG5vb3AgPSAoKT0+e307XG4vLyBVc2luZyBub29wKCkgYXMgdGhlIHVuZGVmaW5lZCB2YWx1ZSBhcyB1bmRlZmluZWQgY2FuIGJlIHJlcGxhY2VkXG4vLyBieSBzb21ldGhpbmcgZWxzZS4gUHJldHRpZXIgaWdub3JlIGFuZCBleHRyYSBwYXJlbnRoZXNlcyBhcmUgbmVjZXNzYXJ5IGhlcmVcbi8vIHRvIGVuc3VyZSB0aGF0IHRzYyBkb2Vzbid0IHJlbW92ZSB0aGUgX19OT0lOTElORV9fIGNvbW1lbnQuXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFVOREVGSU5FRCA9IC8qI19fTk9JTkxJTkVfXyovIG5vb3AoKTtcbmNvbnN0IE9CSkVDVCA9IE9iamVjdDtcbmNvbnN0IGlzVW5kZWZpbmVkID0gKHYpPT52ID09PSBVTkRFRklORUQ7XG5jb25zdCBpc0Z1bmN0aW9uID0gKHYpPT50eXBlb2YgdiA9PSAnZnVuY3Rpb24nO1xuY29uc3QgbWVyZ2VPYmplY3RzID0gKGEsIGIpPT4oe1xuICAgICAgICAuLi5hLFxuICAgICAgICAuLi5iXG4gICAgfSk7XG5jb25zdCBpc1Byb21pc2VMaWtlID0gKHgpPT5pc0Z1bmN0aW9uKHgudGhlbik7XG5cbi8vIHVzZSBXZWFrTWFwIHRvIHN0b3JlIHRoZSBvYmplY3QtPmtleSBtYXBwaW5nXG4vLyBzbyB0aGUgb2JqZWN0cyBjYW4gYmUgZ2FyYmFnZSBjb2xsZWN0ZWQuXG4vLyBXZWFrTWFwIHVzZXMgYSBoYXNodGFibGUgdW5kZXIgdGhlIGhvb2QsIHNvIHRoZSBsb29rdXBcbi8vIGNvbXBsZXhpdHkgaXMgYWxtb3N0IE8oMSkuXG5jb25zdCB0YWJsZSA9IG5ldyBXZWFrTWFwKCk7XG4vLyBjb3VudGVyIG9mIHRoZSBrZXlcbmxldCBjb3VudGVyID0gMDtcbi8vIEEgc3RhYmxlIGhhc2ggaW1wbGVtZW50YXRpb24gdGhhdCBzdXBwb3J0czpcbi8vIC0gRmFzdCBhbmQgZW5zdXJlcyB1bmlxdWUgaGFzaCBwcm9wZXJ0aWVzXG4vLyAtIEhhbmRsZXMgdW5zZXJpYWxpemFibGUgdmFsdWVzXG4vLyAtIEhhbmRsZXMgb2JqZWN0IGtleSBvcmRlcmluZ1xuLy8gLSBHZW5lcmF0ZXMgc2hvcnQgcmVzdWx0c1xuLy9cbi8vIFRoaXMgaXMgbm90IGEgc2VyaWFsaXphdGlvbiBmdW5jdGlvbiwgYW5kIHRoZSByZXN1bHQgaXMgbm90IGd1YXJhbnRlZWQgdG8gYmVcbi8vIHBhcnNhYmxlLlxuY29uc3Qgc3RhYmxlSGFzaCA9IChhcmcpPT57XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBhcmc7XG4gICAgY29uc3QgY29uc3RydWN0b3IgPSBhcmcgJiYgYXJnLmNvbnN0cnVjdG9yO1xuICAgIGNvbnN0IGlzRGF0ZSA9IGNvbnN0cnVjdG9yID09IERhdGU7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBsZXQgaW5kZXg7XG4gICAgaWYgKE9CSkVDVChhcmcpID09PSBhcmcgJiYgIWlzRGF0ZSAmJiBjb25zdHJ1Y3RvciAhPSBSZWdFeHApIHtcbiAgICAgICAgLy8gT2JqZWN0L2Z1bmN0aW9uLCBub3QgbnVsbC9kYXRlL3JlZ2V4cC4gVXNlIFdlYWtNYXAgdG8gc3RvcmUgdGhlIGlkIGZpcnN0LlxuICAgICAgICAvLyBJZiBpdCdzIGFscmVhZHkgaGFzaGVkLCBkaXJlY3RseSByZXR1cm4gdGhlIHJlc3VsdC5cbiAgICAgICAgcmVzdWx0ID0gdGFibGUuZ2V0KGFyZyk7XG4gICAgICAgIGlmIChyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgICAgIC8vIFN0b3JlIHRoZSBoYXNoIGZpcnN0IGZvciBjaXJjdWxhciByZWZlcmVuY2UgZGV0ZWN0aW9uIGJlZm9yZSBlbnRlcmluZyB0aGVcbiAgICAgICAgLy8gcmVjdXJzaXZlIGBzdGFibGVIYXNoYCBjYWxscy5cbiAgICAgICAgLy8gRm9yIG90aGVyIG9iamVjdHMgbGlrZSBzZXQgYW5kIG1hcCwgd2UgdXNlIHRoaXMgaWQgZGlyZWN0bHkgYXMgdGhlIGhhc2guXG4gICAgICAgIHJlc3VsdCA9ICsrY291bnRlciArICd+JztcbiAgICAgICAgdGFibGUuc2V0KGFyZywgcmVzdWx0KTtcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yID09IEFycmF5KSB7XG4gICAgICAgICAgICAvLyBBcnJheS5cbiAgICAgICAgICAgIHJlc3VsdCA9ICdAJztcbiAgICAgICAgICAgIGZvcihpbmRleCA9IDA7IGluZGV4IDwgYXJnLmxlbmd0aDsgaW5kZXgrKyl7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHN0YWJsZUhhc2goYXJnW2luZGV4XSkgKyAnLCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YWJsZS5zZXQoYXJnLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zdHJ1Y3RvciA9PSBPQkpFQ1QpIHtcbiAgICAgICAgICAgIC8vIE9iamVjdCwgc29ydCBrZXlzLlxuICAgICAgICAgICAgcmVzdWx0ID0gJyMnO1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9CSkVDVC5rZXlzKGFyZykuc29ydCgpO1xuICAgICAgICAgICAgd2hpbGUoIWlzVW5kZWZpbmVkKGluZGV4ID0ga2V5cy5wb3AoKSkpe1xuICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQoYXJnW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IGluZGV4ICsgJzonICsgc3RhYmxlSGFzaChhcmdbaW5kZXhdKSArICcsJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YWJsZS5zZXQoYXJnLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0ID0gaXNEYXRlID8gYXJnLnRvSlNPTigpIDogdHlwZSA9PSAnc3ltYm9sJyA/IGFyZy50b1N0cmluZygpIDogdHlwZSA9PSAnc3RyaW5nJyA/IEpTT04uc3RyaW5naWZ5KGFyZykgOiAnJyArIGFyZztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8vIEdsb2JhbCBzdGF0ZSB1c2VkIHRvIGRlZHVwbGljYXRlIHJlcXVlc3RzIGFuZCBzdG9yZSBsaXN0ZW5lcnNcbmNvbnN0IFNXUkdsb2JhbFN0YXRlID0gbmV3IFdlYWtNYXAoKTtcblxuY29uc3QgRU1QVFlfQ0FDSEUgPSB7fTtcbmNvbnN0IElOSVRJQUxfQ0FDSEUgPSB7fTtcbmNvbnN0IFNUUl9VTkRFRklORUQgPSAndW5kZWZpbmVkJztcbi8vIE5PVEU6IFVzZSB0aGUgZnVuY3Rpb24gdG8gZ3VhcmFudGVlIGl0J3MgcmUtZXZhbHVhdGVkIGJldHdlZW4ganNkb20gYW5kIG5vZGUgcnVudGltZSBmb3IgdGVzdHMuXG5jb25zdCBpc1dpbmRvd0RlZmluZWQgPSB0eXBlb2Ygd2luZG93ICE9IFNUUl9VTkRFRklORUQ7XG5jb25zdCBpc0RvY3VtZW50RGVmaW5lZCA9IHR5cGVvZiBkb2N1bWVudCAhPSBTVFJfVU5ERUZJTkVEO1xuY29uc3QgaGFzUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gKCk9PmlzV2luZG93RGVmaW5lZCAmJiB0eXBlb2Ygd2luZG93WydyZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXSAhPSBTVFJfVU5ERUZJTkVEO1xuY29uc3QgY3JlYXRlQ2FjaGVIZWxwZXIgPSAoY2FjaGUsIGtleSk9PntcbiAgICBjb25zdCBzdGF0ZSA9IFNXUkdsb2JhbFN0YXRlLmdldChjYWNoZSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgLy8gR2V0dGVyXG4gICAgICAgICgpPT4haXNVbmRlZmluZWQoa2V5KSAmJiBjYWNoZS5nZXQoa2V5KSB8fCBFTVBUWV9DQUNIRSxcbiAgICAgICAgLy8gU2V0dGVyXG4gICAgICAgIChpbmZvKT0+e1xuICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChrZXkpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldiA9IGNhY2hlLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIC8vIEJlZm9yZSB3cml0aW5nIHRvIHRoZSBzdG9yZSwgd2Uga2VlcCB0aGUgdmFsdWUgaW4gdGhlIGluaXRpYWwgY2FjaGVcbiAgICAgICAgICAgICAgICAvLyBpZiBpdCdzIG5vdCB0aGVyZSB5ZXQuXG4gICAgICAgICAgICAgICAgaWYgKCEoa2V5IGluIElOSVRJQUxfQ0FDSEUpKSB7XG4gICAgICAgICAgICAgICAgICAgIElOSVRJQUxfQ0FDSEVba2V5XSA9IHByZXY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlWzVdKGtleSwgbWVyZ2VPYmplY3RzKHByZXYsIGluZm8pLCBwcmV2IHx8IEVNUFRZX0NBQ0hFKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gU3Vic2NyaWJlclxuICAgICAgICBzdGF0ZVs2XSxcbiAgICAgICAgLy8gR2V0IHNlcnZlciBjYWNoZSBzbmFwc2hvdFxuICAgICAgICAoKT0+e1xuICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChrZXkpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGNhY2hlIHdhcyB1cGRhdGVkIG9uIHRoZSBjbGllbnQsIHdlIHJldHVybiB0aGUgc3RvcmVkIGluaXRpYWwgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKGtleSBpbiBJTklUSUFMX0NBQ0hFKSByZXR1cm4gSU5JVElBTF9DQUNIRVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZW4ndCBkb25lIGFueSBjbGllbnQtc2lkZSB1cGRhdGVzLCB3ZSByZXR1cm4gdGhlIGN1cnJlbnQgdmFsdWUuXG4gICAgICAgICAgICByZXR1cm4gIWlzVW5kZWZpbmVkKGtleSkgJiYgY2FjaGUuZ2V0KGtleSkgfHwgRU1QVFlfQ0FDSEU7XG4gICAgICAgIH1cbiAgICBdO1xufSAvLyBleHBvcnQgeyBVTkRFRklORUQsIE9CSkVDVCwgaXNVbmRlZmluZWQsIGlzRnVuY3Rpb24sIG1lcmdlT2JqZWN0cywgaXNQcm9taXNlTGlrZSB9XG47XG5cbi8qKlxuICogRHVlIHRvIHRoZSBidWcgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Njc4MDc1LFxuICogaXQncyBub3QgcmVsaWFibGUgdG8gZGV0ZWN0IGlmIHRoZSBicm93c2VyIGlzIGN1cnJlbnRseSBvbmxpbmUgb3Igb2ZmbGluZVxuICogYmFzZWQgb24gYG5hdmlnYXRvci5vbkxpbmVgLlxuICogQXMgYSB3b3JrYXJvdW5kLCB3ZSBhbHdheXMgYXNzdW1lIGl0J3Mgb25saW5lIG9uIHRoZSBmaXJzdCBsb2FkLCBhbmQgY2hhbmdlXG4gKiB0aGUgc3RhdHVzIHVwb24gYG9ubGluZWAgb3IgYG9mZmxpbmVgIGV2ZW50cy5cbiAqLyBsZXQgb25saW5lID0gdHJ1ZTtcbmNvbnN0IGlzT25saW5lID0gKCk9Pm9ubGluZTtcbi8vIEZvciBub2RlIGFuZCBSZWFjdCBOYXRpdmUsIGBhZGQvcmVtb3ZlRXZlbnRMaXN0ZW5lcmAgZG9lc24ndCBleGlzdCBvbiB3aW5kb3cuXG5jb25zdCBbb25XaW5kb3dFdmVudCwgb2ZmV2luZG93RXZlbnRdID0gaXNXaW5kb3dEZWZpbmVkICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyID8gW1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyLmJpbmQod2luZG93KSxcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lci5iaW5kKHdpbmRvdylcbl0gOiBbXG4gICAgbm9vcCxcbiAgICBub29wXG5dO1xuY29uc3QgaXNWaXNpYmxlID0gKCk9PntcbiAgICBjb25zdCB2aXNpYmlsaXR5U3RhdGUgPSBpc0RvY3VtZW50RGVmaW5lZCAmJiBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGU7XG4gICAgcmV0dXJuIGlzVW5kZWZpbmVkKHZpc2liaWxpdHlTdGF0ZSkgfHwgdmlzaWJpbGl0eVN0YXRlICE9PSAnaGlkZGVuJztcbn07XG5jb25zdCBpbml0Rm9jdXMgPSAoY2FsbGJhY2spPT57XG4gICAgLy8gZm9jdXMgcmV2YWxpZGF0ZVxuICAgIGlmIChpc0RvY3VtZW50RGVmaW5lZCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgY2FsbGJhY2spO1xuICAgIH1cbiAgICBvbldpbmRvd0V2ZW50KCdmb2N1cycsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gKCk9PntcbiAgICAgICAgaWYgKGlzRG9jdW1lbnREZWZpbmVkKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIG9mZldpbmRvd0V2ZW50KCdmb2N1cycsIGNhbGxiYWNrKTtcbiAgICB9O1xufTtcbmNvbnN0IGluaXRSZWNvbm5lY3QgPSAoY2FsbGJhY2spPT57XG4gICAgLy8gcmV2YWxpZGF0ZSBvbiByZWNvbm5lY3RlZFxuICAgIGNvbnN0IG9uT25saW5lID0gKCk9PntcbiAgICAgICAgb25saW5lID0gdHJ1ZTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9O1xuICAgIC8vIG5vdGhpbmcgdG8gcmV2YWxpZGF0ZSwganVzdCB1cGRhdGUgdGhlIHN0YXR1c1xuICAgIGNvbnN0IG9uT2ZmbGluZSA9ICgpPT57XG4gICAgICAgIG9ubGluZSA9IGZhbHNlO1xuICAgIH07XG4gICAgb25XaW5kb3dFdmVudCgnb25saW5lJywgb25PbmxpbmUpO1xuICAgIG9uV2luZG93RXZlbnQoJ29mZmxpbmUnLCBvbk9mZmxpbmUpO1xuICAgIHJldHVybiAoKT0+e1xuICAgICAgICBvZmZXaW5kb3dFdmVudCgnb25saW5lJywgb25PbmxpbmUpO1xuICAgICAgICBvZmZXaW5kb3dFdmVudCgnb2ZmbGluZScsIG9uT2ZmbGluZSk7XG4gICAgfTtcbn07XG5jb25zdCBwcmVzZXQgPSB7XG4gICAgaXNPbmxpbmUsXG4gICAgaXNWaXNpYmxlXG59O1xuY29uc3QgZGVmYXVsdENvbmZpZ09wdGlvbnMgPSB7XG4gICAgaW5pdEZvY3VzLFxuICAgIGluaXRSZWNvbm5lY3Rcbn07XG5cbmNvbnN0IElTX1JFQUNUX0xFR0FDWSA9ICFSZWFjdC51c2VJZDtcbmNvbnN0IElTX1NFUlZFUiA9ICFpc1dpbmRvd0RlZmluZWQgfHwgJ0Rlbm8nIGluIHdpbmRvdztcbi8vIFBvbHlmaWxsIHJlcXVlc3RBbmltYXRpb25GcmFtZVxuY29uc3QgckFGID0gKGYpPT5oYXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKSA/IHdpbmRvd1sncmVxdWVzdEFuaW1hdGlvbkZyYW1lJ10oZikgOiBzZXRUaW1lb3V0KGYsIDEpO1xuLy8gUmVhY3QgY3VycmVudGx5IHRocm93cyBhIHdhcm5pbmcgd2hlbiB1c2luZyB1c2VMYXlvdXRFZmZlY3Qgb24gdGhlIHNlcnZlci5cbi8vIFRvIGdldCBhcm91bmQgaXQsIHdlIGNhbiBjb25kaXRpb25hbGx5IHVzZUVmZmVjdCBvbiB0aGUgc2VydmVyIChuby1vcCkgYW5kXG4vLyB1c2VMYXlvdXRFZmZlY3QgaW4gdGhlIGJyb3dzZXIuXG5jb25zdCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gSVNfU0VSVkVSID8gdXNlRWZmZWN0IDogdXNlTGF5b3V0RWZmZWN0O1xuLy8gVGhpcyBhc3NpZ25tZW50IGlzIHRvIGV4dGVuZCB0aGUgTmF2aWdhdG9yIHR5cGUgdG8gdXNlIGVmZmVjdGl2ZVR5cGUuXG5jb25zdCBuYXZpZ2F0b3JDb25uZWN0aW9uID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLmNvbm5lY3Rpb247XG4vLyBBZGp1c3QgdGhlIGNvbmZpZyBiYXNlZCBvbiBzbG93IGNvbm5lY3Rpb24gc3RhdHVzICg8PSA3MEticHMpLlxuY29uc3Qgc2xvd0Nvbm5lY3Rpb24gPSAhSVNfU0VSVkVSICYmIG5hdmlnYXRvckNvbm5lY3Rpb24gJiYgKFtcbiAgICAnc2xvdy0yZycsXG4gICAgJzJnJ1xuXS5pbmNsdWRlcyhuYXZpZ2F0b3JDb25uZWN0aW9uLmVmZmVjdGl2ZVR5cGUpIHx8IG5hdmlnYXRvckNvbm5lY3Rpb24uc2F2ZURhdGEpO1xuXG5jb25zdCBzZXJpYWxpemUgPSAoa2V5KT0+e1xuICAgIGlmIChpc0Z1bmN0aW9uKGtleSkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGtleSA9IGtleSgpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIC8vIGRlcGVuZGVuY2llcyBub3QgcmVhZHlcbiAgICAgICAgICAgIGtleSA9ICcnO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFVzZSB0aGUgb3JpZ2luYWwga2V5IGFzIHRoZSBhcmd1bWVudCBvZiBmZXRjaGVyLiBUaGlzIGNhbiBiZSBhIHN0cmluZyBvciBhblxuICAgIC8vIGFycmF5IG9mIHZhbHVlcy5cbiAgICBjb25zdCBhcmdzID0ga2V5O1xuICAgIC8vIElmIGtleSBpcyBub3QgZmFsc3ksIG9yIG5vdCBhbiBlbXB0eSBhcnJheSwgaGFzaCBpdC5cbiAgICBrZXkgPSB0eXBlb2Yga2V5ID09ICdzdHJpbmcnID8ga2V5IDogKEFycmF5LmlzQXJyYXkoa2V5KSA/IGtleS5sZW5ndGggOiBrZXkpID8gc3RhYmxlSGFzaChrZXkpIDogJyc7XG4gICAgcmV0dXJuIFtcbiAgICAgICAga2V5LFxuICAgICAgICBhcmdzXG4gICAgXTtcbn07XG5cbi8vIEdsb2JhbCB0aW1lc3RhbXAuXG5sZXQgX190aW1lc3RhbXAgPSAwO1xuY29uc3QgZ2V0VGltZXN0YW1wID0gKCk9PisrX190aW1lc3RhbXA7XG5cbmNvbnN0IEZPQ1VTX0VWRU5UID0gMDtcbmNvbnN0IFJFQ09OTkVDVF9FVkVOVCA9IDE7XG5jb25zdCBNVVRBVEVfRVZFTlQgPSAyO1xuY29uc3QgRVJST1JfUkVWQUxJREFURV9FVkVOVCA9IDM7XG5cbnZhciBjb25zdGFudHMgPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgRVJST1JfUkVWQUxJREFURV9FVkVOVDogRVJST1JfUkVWQUxJREFURV9FVkVOVCxcbiAgRk9DVVNfRVZFTlQ6IEZPQ1VTX0VWRU5ULFxuICBNVVRBVEVfRVZFTlQ6IE1VVEFURV9FVkVOVCxcbiAgUkVDT05ORUNUX0VWRU5UOiBSRUNPTk5FQ1RfRVZFTlRcbn07XG5cbmFzeW5jIGZ1bmN0aW9uIGludGVybmFsTXV0YXRlKC4uLmFyZ3MpIHtcbiAgICBjb25zdCBbY2FjaGUsIF9rZXksIF9kYXRhLCBfb3B0c10gPSBhcmdzO1xuICAgIC8vIFdoZW4gcGFzc2luZyBhcyBhIGJvb2xlYW4sIGl0J3MgZXhwbGljaXRseSB1c2VkIHRvIGRpc2FibGUvZW5hYmxlXG4gICAgLy8gcmV2YWxpZGF0aW9uLlxuICAgIGNvbnN0IG9wdGlvbnMgPSBtZXJnZU9iamVjdHMoe1xuICAgICAgICBwb3B1bGF0ZUNhY2hlOiB0cnVlLFxuICAgICAgICB0aHJvd09uRXJyb3I6IHRydWVcbiAgICB9LCB0eXBlb2YgX29wdHMgPT09ICdib29sZWFuJyA/IHtcbiAgICAgICAgcmV2YWxpZGF0ZTogX29wdHNcbiAgICB9IDogX29wdHMgfHwge30pO1xuICAgIGxldCBwb3B1bGF0ZUNhY2hlID0gb3B0aW9ucy5wb3B1bGF0ZUNhY2hlO1xuICAgIGNvbnN0IHJvbGxiYWNrT25FcnJvck9wdGlvbiA9IG9wdGlvbnMucm9sbGJhY2tPbkVycm9yO1xuICAgIGxldCBvcHRpbWlzdGljRGF0YSA9IG9wdGlvbnMub3B0aW1pc3RpY0RhdGE7XG4gICAgY29uc3QgcmV2YWxpZGF0ZSA9IG9wdGlvbnMucmV2YWxpZGF0ZSAhPT0gZmFsc2U7XG4gICAgY29uc3Qgcm9sbGJhY2tPbkVycm9yID0gKGVycm9yKT0+e1xuICAgICAgICByZXR1cm4gdHlwZW9mIHJvbGxiYWNrT25FcnJvck9wdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IHJvbGxiYWNrT25FcnJvck9wdGlvbihlcnJvcikgOiByb2xsYmFja09uRXJyb3JPcHRpb24gIT09IGZhbHNlO1xuICAgIH07XG4gICAgY29uc3QgdGhyb3dPbkVycm9yID0gb3B0aW9ucy50aHJvd09uRXJyb3I7XG4gICAgLy8gSWYgdGhlIHNlY29uZCBhcmd1bWVudCBpcyBhIGtleSBmaWx0ZXIsIHJldHVybiB0aGUgbXV0YXRpb24gcmVzdWx0cyBmb3IgYWxsXG4gICAgLy8gZmlsdGVyZWQga2V5cy5cbiAgICBpZiAoaXNGdW5jdGlvbihfa2V5KSkge1xuICAgICAgICBjb25zdCBrZXlGaWx0ZXIgPSBfa2V5O1xuICAgICAgICBjb25zdCBtYXRjaGVkS2V5cyA9IFtdO1xuICAgICAgICBjb25zdCBpdCA9IGNhY2hlLmtleXMoKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgaXQpe1xuICAgICAgICAgICAgaWYgKC8vIFNraXAgdGhlIHNwZWNpYWwgdXNlU1dSSW5maW5pdGUgYW5kIHVzZVNXUlN1YnNjcmlwdGlvbiBrZXlzLlxuICAgICAgICAgICAgIS9eXFwkKGluZnxzdWIpXFwkLy50ZXN0KGtleSkgJiYga2V5RmlsdGVyKGNhY2hlLmdldChrZXkpLl9rKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoZWRLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwobWF0Y2hlZEtleXMubWFwKG11dGF0ZUJ5S2V5KSk7XG4gICAgfVxuICAgIHJldHVybiBtdXRhdGVCeUtleShfa2V5KTtcbiAgICBhc3luYyBmdW5jdGlvbiBtdXRhdGVCeUtleShfaykge1xuICAgICAgICAvLyBTZXJpYWxpemUga2V5XG4gICAgICAgIGNvbnN0IFtrZXldID0gc2VyaWFsaXplKF9rKTtcbiAgICAgICAgaWYgKCFrZXkpIHJldHVybjtcbiAgICAgICAgY29uc3QgW2dldCwgc2V0XSA9IGNyZWF0ZUNhY2hlSGVscGVyKGNhY2hlLCBrZXkpO1xuICAgICAgICBjb25zdCBbRVZFTlRfUkVWQUxJREFUT1JTLCBNVVRBVElPTiwgRkVUQ0gsIFBSRUxPQURdID0gU1dSR2xvYmFsU3RhdGUuZ2V0KGNhY2hlKTtcbiAgICAgICAgY29uc3QgcmV2YWxpZGF0b3JzID0gRVZFTlRfUkVWQUxJREFUT1JTW2tleV07XG4gICAgICAgIGNvbnN0IHN0YXJ0UmV2YWxpZGF0ZSA9ICgpPT57XG4gICAgICAgICAgICBpZiAocmV2YWxpZGF0ZSkge1xuICAgICAgICAgICAgICAgIC8vIEludmFsaWRhdGUgdGhlIGtleSBieSBkZWxldGluZyB0aGUgY29uY3VycmVudCByZXF1ZXN0IG1hcmtlcnMgc28gbmV3XG4gICAgICAgICAgICAgICAgLy8gcmVxdWVzdHMgd2lsbCBub3QgYmUgZGVkdXBlZC5cbiAgICAgICAgICAgICAgICBkZWxldGUgRkVUQ0hba2V5XTtcbiAgICAgICAgICAgICAgICBkZWxldGUgUFJFTE9BRFtrZXldO1xuICAgICAgICAgICAgICAgIGlmIChyZXZhbGlkYXRvcnMgJiYgcmV2YWxpZGF0b3JzWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXZhbGlkYXRvcnNbMF0oTVVUQVRFX0VWRU5UKS50aGVuKCgpPT5nZXQoKS5kYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2V0KCkuZGF0YTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gbmV3IGRhdGEgcHJvdmlkZWQsIHJldmFsaWRhdGUgdGhlIGtleSB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICAgIC8vIFJldmFsaWRhdGUgYW5kIGJyb2FkY2FzdCBzdGF0ZS5cbiAgICAgICAgICAgIHJldHVybiBzdGFydFJldmFsaWRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YSA9IF9kYXRhO1xuICAgICAgICBsZXQgZXJyb3I7XG4gICAgICAgIC8vIFVwZGF0ZSBnbG9iYWwgdGltZXN0YW1wcy5cbiAgICAgICAgY29uc3QgYmVmb3JlTXV0YXRpb25UcyA9IGdldFRpbWVzdGFtcCgpO1xuICAgICAgICBNVVRBVElPTltrZXldID0gW1xuICAgICAgICAgICAgYmVmb3JlTXV0YXRpb25UcyxcbiAgICAgICAgICAgIDBcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgaGFzT3B0aW1pc3RpY0RhdGEgPSAhaXNVbmRlZmluZWQob3B0aW1pc3RpY0RhdGEpO1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGdldCgpO1xuICAgICAgICAvLyBgZGlzcGxheWVkRGF0YWAgaXMgdGhlIGN1cnJlbnQgdmFsdWUgb24gc2NyZWVuLiBJdCBjb3VsZCBiZSB0aGUgb3B0aW1pc3RpYyB2YWx1ZVxuICAgICAgICAvLyB0aGF0IGlzIGdvaW5nIHRvIGJlIG92ZXJyaWRkZW4gYnkgYSBgY29tbWl0dGVkRGF0YWAsIG9yIGdldCByZXZlcnRlZCBiYWNrLlxuICAgICAgICAvLyBgY29tbWl0dGVkRGF0YWAgaXMgdGhlIHZhbGlkYXRlZCB2YWx1ZSB0aGF0IGNvbWVzIGZyb20gYSBmZXRjaCBvciBtdXRhdGlvbi5cbiAgICAgICAgY29uc3QgZGlzcGxheWVkRGF0YSA9IHN0YXRlLmRhdGE7XG4gICAgICAgIGNvbnN0IGN1cnJlbnREYXRhID0gc3RhdGUuX2M7XG4gICAgICAgIGNvbnN0IGNvbW1pdHRlZERhdGEgPSBpc1VuZGVmaW5lZChjdXJyZW50RGF0YSkgPyBkaXNwbGF5ZWREYXRhIDogY3VycmVudERhdGE7XG4gICAgICAgIC8vIERvIG9wdGltaXN0aWMgZGF0YSB1cGRhdGUuXG4gICAgICAgIGlmIChoYXNPcHRpbWlzdGljRGF0YSkge1xuICAgICAgICAgICAgb3B0aW1pc3RpY0RhdGEgPSBpc0Z1bmN0aW9uKG9wdGltaXN0aWNEYXRhKSA/IG9wdGltaXN0aWNEYXRhKGNvbW1pdHRlZERhdGEsIGRpc3BsYXllZERhdGEpIDogb3B0aW1pc3RpY0RhdGE7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIHNldCBvcHRpbWlzdGljIGRhdGEsIGJhY2t1cCB0aGUgY3VycmVudCBjb21taXR0ZWREYXRhIGRhdGEgaW4gYF9jYC5cbiAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgICAgZGF0YTogb3B0aW1pc3RpY0RhdGEsXG4gICAgICAgICAgICAgICAgX2M6IGNvbW1pdHRlZERhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKGRhdGEpKSB7XG4gICAgICAgICAgICAvLyBgZGF0YWAgaXMgYSBmdW5jdGlvbiwgY2FsbCBpdCBwYXNzaW5nIGN1cnJlbnQgY2FjaGUgdmFsdWUuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhKGNvbW1pdHRlZERhdGEpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXQgdGhyb3dzIGFuIGVycm9yIHN5bmNocm9ub3VzbHksIHdlIHNob3VsZG4ndCB1cGRhdGUgdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgIGVycm9yID0gZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGBkYXRhYCBpcyBhIHByb21pc2UvdGhlbmFibGUsIHJlc29sdmUgdGhlIGZpbmFsIGRhdGEgZmlyc3QuXG4gICAgICAgIGlmIChkYXRhICYmIGlzUHJvbWlzZUxpa2UoZGF0YSkpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB0aGUgbXV0YXRpb24gaXMgYXN5bmMsIHdlIG5lZWQgdG8gY2hlY2sgdGltZXN0YW1wcyB0b1xuICAgICAgICAgICAgLy8gYXZvaWQgcmFjZSBjb25kaXRpb25zLlxuICAgICAgICAgICAgZGF0YSA9IGF3YWl0IGRhdGEuY2F0Y2goKGVycik9PntcbiAgICAgICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgb3RoZXIgbXV0YXRpb25zIGhhdmUgb2NjdXJyZWQgc2luY2Ugd2UndmUgc3RhcnRlZCB0aGlzIG11dGF0aW9uLlxuICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIHJhY2Ugd2UgZG9uJ3QgdXBkYXRlIGNhY2hlIG9yIGJyb2FkY2FzdCB0aGUgY2hhbmdlLFxuICAgICAgICAgICAgLy8ganVzdCByZXR1cm4gdGhlIGRhdGEuXG4gICAgICAgICAgICBpZiAoYmVmb3JlTXV0YXRpb25UcyAhPT0gTVVUQVRJT05ba2V5XVswXSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yICYmIGhhc09wdGltaXN0aWNEYXRhICYmIHJvbGxiYWNrT25FcnJvcihlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAvLyBSb2xsYmFjay4gQWx3YXlzIHBvcHVsYXRlIHRoZSBjYWNoZSBpbiB0aGlzIGNhc2UgYnV0IHdpdGhvdXRcbiAgICAgICAgICAgICAgICAvLyB0cmFuc2Zvcm1pbmcgdGhlIGRhdGEuXG4gICAgICAgICAgICAgICAgcG9wdWxhdGVDYWNoZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGNvbW1pdHRlZERhdGE7XG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgZGF0YSB0byBiZSB0aGUgbGF0ZXN0IGNvbW1pdHRlZCBkYXRhLCBhbmQgY2xlYXIgdGhlIGBfY2AgdmFsdWUuXG4gICAgICAgICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgX2M6IFVOREVGSU5FRFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIHNob3VsZCB3cml0ZSBiYWNrIHRoZSBjYWNoZSBhZnRlciByZXF1ZXN0LlxuICAgICAgICBpZiAocG9wdWxhdGVDYWNoZSkge1xuICAgICAgICAgICAgaWYgKCFlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIFRyYW5zZm9ybSB0aGUgcmVzdWx0IGludG8gZGF0YS5cbiAgICAgICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihwb3B1bGF0ZUNhY2hlKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhID0gcG9wdWxhdGVDYWNoZShkYXRhLCBjb21taXR0ZWREYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gT25seSB1cGRhdGUgY2FjaGVkIGRhdGEgYW5kIHJlc2V0IHRoZSBlcnJvciBpZiB0aGVyZSdzIG5vIGVycm9yLiBEYXRhIGNhbiBiZSBgdW5kZWZpbmVkYCBoZXJlLlxuICAgICAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBVTkRFRklORUQsXG4gICAgICAgICAgICAgICAgICAgIF9jOiBVTkRFRklORURcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNldCB0aGUgdGltZXN0YW1wIHRvIG1hcmsgdGhlIG11dGF0aW9uIGhhcyBlbmRlZC5cbiAgICAgICAgTVVUQVRJT05ba2V5XVsxXSA9IGdldFRpbWVzdGFtcCgpO1xuICAgICAgICAvLyBVcGRhdGUgZXhpc3RpbmcgU1dSIEhvb2tzJyBpbnRlcm5hbCBzdGF0ZXM6XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHN0YXJ0UmV2YWxpZGF0ZSgpO1xuICAgICAgICAvLyBUaGUgbXV0YXRpb24gYW5kIHJldmFsaWRhdGlvbiBhcmUgZW5kZWQsIHdlIGNhbiBjbGVhciBpdCBzaW5jZSB0aGUgZGF0YSBpc1xuICAgICAgICAvLyBub3QgYW4gb3B0aW1pc3RpYyB2YWx1ZSBhbnltb3JlLlxuICAgICAgICBzZXQoe1xuICAgICAgICAgICAgX2M6IFVOREVGSU5FRFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVGhyb3cgZXJyb3Igb3IgcmV0dXJuIGRhdGFcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAodGhyb3dPbkVycm9yKSB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcG9wdWxhdGVDYWNoZSA/IHJlcyA6IGRhdGE7XG4gICAgfVxufVxuXG5jb25zdCByZXZhbGlkYXRlQWxsS2V5cyA9IChyZXZhbGlkYXRvcnMsIHR5cGUpPT57XG4gICAgZm9yKGNvbnN0IGtleSBpbiByZXZhbGlkYXRvcnMpe1xuICAgICAgICBpZiAocmV2YWxpZGF0b3JzW2tleV1bMF0pIHJldmFsaWRhdG9yc1trZXldWzBdKHR5cGUpO1xuICAgIH1cbn07XG5jb25zdCBpbml0Q2FjaGUgPSAocHJvdmlkZXIsIG9wdGlvbnMpPT57XG4gICAgLy8gVGhlIGdsb2JhbCBzdGF0ZSBmb3IgYSBzcGVjaWZpYyBwcm92aWRlciB3aWxsIGJlIHVzZWQgdG8gZGVkdXBsaWNhdGVcbiAgICAvLyByZXF1ZXN0cyBhbmQgc3RvcmUgbGlzdGVuZXJzLiBBcyB3ZWxsIGFzIGEgbXV0YXRlIGZ1bmN0aW9uIHRoYXQgaXMgYm91bmQgdG9cbiAgICAvLyB0aGUgY2FjaGUuXG4gICAgLy8gVGhlIHByb3ZpZGVyJ3MgZ2xvYmFsIHN0YXRlIG1pZ2h0IGJlIGFscmVhZHkgaW5pdGlhbGl6ZWQuIExldCdzIHRyeSB0byBnZXQgdGhlXG4gICAgLy8gZ2xvYmFsIHN0YXRlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcHJvdmlkZXIgZmlyc3QuXG4gICAgaWYgKCFTV1JHbG9iYWxTdGF0ZS5oYXMocHJvdmlkZXIpKSB7XG4gICAgICAgIGNvbnN0IG9wdHMgPSBtZXJnZU9iamVjdHMoZGVmYXVsdENvbmZpZ09wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGdsb2JhbCBzdGF0ZSBib3VuZCB0byB0aGUgcHJvdmlkZXIsIGNyZWF0ZSBhIG5ldyBvbmUgd2l0aCB0aGVcbiAgICAgICAgLy8gbmV3IG11dGF0ZSBmdW5jdGlvbi5cbiAgICAgICAgY29uc3QgRVZFTlRfUkVWQUxJREFUT1JTID0ge307XG4gICAgICAgIGNvbnN0IG11dGF0ZSA9IGludGVybmFsTXV0YXRlLmJpbmQoVU5ERUZJTkVELCBwcm92aWRlcik7XG4gICAgICAgIGxldCB1bm1vdW50ID0gbm9vcDtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IHt9O1xuICAgICAgICBjb25zdCBzdWJzY3JpYmUgPSAoa2V5LCBjYWxsYmFjayk9PntcbiAgICAgICAgICAgIGNvbnN0IHN1YnMgPSBzdWJzY3JpcHRpb25zW2tleV0gfHwgW107XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25zW2tleV0gPSBzdWJzO1xuICAgICAgICAgICAgc3Vicy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJldHVybiAoKT0+c3Vicy5zcGxpY2Uoc3Vicy5pbmRleE9mKGNhbGxiYWNrKSwgMSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNldHRlciA9IChrZXksIHZhbHVlLCBwcmV2KT0+e1xuICAgICAgICAgICAgcHJvdmlkZXIuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgY29uc3Qgc3VicyA9IHN1YnNjcmlwdGlvbnNba2V5XTtcbiAgICAgICAgICAgIGlmIChzdWJzKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBmbiBvZiBzdWJzKXtcbiAgICAgICAgICAgICAgICAgICAgZm4odmFsdWUsIHByZXYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaW5pdFByb3ZpZGVyID0gKCk9PntcbiAgICAgICAgICAgIGlmICghU1dSR2xvYmFsU3RhdGUuaGFzKHByb3ZpZGVyKSkge1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgc3RhdGUgaWYgaXQncyBuZXcsIG9yIGlmIHRoZSBwcm92aWRlciBoYXMgYmVlbiBleHRlbmRlZC5cbiAgICAgICAgICAgICAgICBTV1JHbG9iYWxTdGF0ZS5zZXQocHJvdmlkZXIsIFtcbiAgICAgICAgICAgICAgICAgICAgRVZFTlRfUkVWQUxJREFUT1JTLFxuICAgICAgICAgICAgICAgICAgICB7fSxcbiAgICAgICAgICAgICAgICAgICAge30sXG4gICAgICAgICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICAgICAgICBtdXRhdGUsXG4gICAgICAgICAgICAgICAgICAgIHNldHRlcixcbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgaWYgKCFJU19TRVJWRVIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiBsaXN0ZW5pbmcgdG8gdGhlIG5hdGl2ZSBldmVudHMgZm9yIGF1dG8gcmV2YWxpZGF0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgaW50ZW50aW9uYWxseSBwdXQgYSBkZWxheSAoc2V0VGltZW91dCkgaGVyZSB0byBtYWtlIHN1cmUgdGhleSBhcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gZmlyZWQgYWZ0ZXIgaW1tZWRpYXRlIEphdmFTY3JpcHQgZXhlY3V0aW9ucywgd2hpY2ggY2FuIGJlXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlYWN0J3Mgc3RhdGUgdXBkYXRlcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBhdm9pZHMgc29tZSB1bm5lY2Vzc2FyeSByZXZhbGlkYXRpb25zIHN1Y2ggYXNcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9zd3IvaXNzdWVzLzE2ODAuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbGVhc2VGb2N1cyA9IG9wdHMuaW5pdEZvY3VzKHNldFRpbWVvdXQuYmluZChVTkRFRklORUQsIHJldmFsaWRhdGVBbGxLZXlzLmJpbmQoVU5ERUZJTkVELCBFVkVOVF9SRVZBTElEQVRPUlMsIEZPQ1VTX0VWRU5UKSkpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWxlYXNlUmVjb25uZWN0ID0gb3B0cy5pbml0UmVjb25uZWN0KHNldFRpbWVvdXQuYmluZChVTkRFRklORUQsIHJldmFsaWRhdGVBbGxLZXlzLmJpbmQoVU5ERUZJTkVELCBFVkVOVF9SRVZBTElEQVRPUlMsIFJFQ09OTkVDVF9FVkVOVCkpKTtcbiAgICAgICAgICAgICAgICAgICAgdW5tb3VudCA9ICgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxlYXNlRm9jdXMgJiYgcmVsZWFzZUZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWxlYXNlUmVjb25uZWN0ICYmIHJlbGVhc2VSZWNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdW4tbW91bnRpbmcsIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSBjYWNoZSBwcm92aWRlciBmcm9tIHRoZSBzdGF0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RvcmFnZSB0b28gYmVjYXVzZSBpdCdzIGEgc2lkZS1lZmZlY3QuIE90aGVyd2lzZSwgd2hlbiByZS1tb3VudGluZyB3ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2lsbCBub3QgcmUtcmVnaXN0ZXIgdGhvc2UgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAgICAgICAgICAgICAgICAgICAgU1dSR2xvYmFsU3RhdGUuZGVsZXRlKHByb3ZpZGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGluaXRQcm92aWRlcigpO1xuICAgICAgICAvLyBUaGlzIGlzIGEgbmV3IHByb3ZpZGVyLCB3ZSBuZWVkIHRvIGluaXRpYWxpemUgaXQgYW5kIHNldHVwIERPTSBldmVudHNcbiAgICAgICAgLy8gbGlzdGVuZXJzIGZvciBgZm9jdXNgIGFuZCBgcmVjb25uZWN0YCBhY3Rpb25zLlxuICAgICAgICAvLyBXZSBtaWdodCB3YW50IHRvIGluamVjdCBhbiBleHRyYSBsYXllciBvbiB0b3Agb2YgYHByb3ZpZGVyYCBpbiB0aGUgZnV0dXJlLFxuICAgICAgICAvLyBzdWNoIGFzIGtleSBzZXJpYWxpemF0aW9uLCBhdXRvIEdDLCBldGMuXG4gICAgICAgIC8vIEZvciBub3csIGl0J3MganVzdCBhIGBNYXBgIGludGVyZmFjZSB3aXRob3V0IGFueSBtb2RpZmljYXRpb25zLlxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICBtdXRhdGUsXG4gICAgICAgICAgICBpbml0UHJvdmlkZXIsXG4gICAgICAgICAgICB1bm1vdW50XG4gICAgICAgIF07XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAgIHByb3ZpZGVyLFxuICAgICAgICBTV1JHbG9iYWxTdGF0ZS5nZXQocHJvdmlkZXIpWzRdXG4gICAgXTtcbn07XG5cbi8vIGVycm9yIHJldHJ5XG5jb25zdCBvbkVycm9yUmV0cnkgPSAoXywgX18sIGNvbmZpZywgcmV2YWxpZGF0ZSwgb3B0cyk9PntcbiAgICBjb25zdCBtYXhSZXRyeUNvdW50ID0gY29uZmlnLmVycm9yUmV0cnlDb3VudDtcbiAgICBjb25zdCBjdXJyZW50UmV0cnlDb3VudCA9IG9wdHMucmV0cnlDb3VudDtcbiAgICAvLyBFeHBvbmVudGlhbCBiYWNrb2ZmXG4gICAgY29uc3QgdGltZW91dCA9IH5+KChNYXRoLnJhbmRvbSgpICsgMC41KSAqICgxIDw8IChjdXJyZW50UmV0cnlDb3VudCA8IDggPyBjdXJyZW50UmV0cnlDb3VudCA6IDgpKSkgKiBjb25maWcuZXJyb3JSZXRyeUludGVydmFsO1xuICAgIGlmICghaXNVbmRlZmluZWQobWF4UmV0cnlDb3VudCkgJiYgY3VycmVudFJldHJ5Q291bnQgPiBtYXhSZXRyeUNvdW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0VGltZW91dChyZXZhbGlkYXRlLCB0aW1lb3V0LCBvcHRzKTtcbn07XG5jb25zdCBjb21wYXJlID0gKGN1cnJlbnREYXRhLCBuZXdEYXRhKT0+c3RhYmxlSGFzaChjdXJyZW50RGF0YSkgPT0gc3RhYmxlSGFzaChuZXdEYXRhKTtcbi8vIERlZmF1bHQgY2FjaGUgcHJvdmlkZXJcbmNvbnN0IFtjYWNoZSwgbXV0YXRlXSA9IGluaXRDYWNoZShuZXcgTWFwKCkpO1xuLy8gRGVmYXVsdCBjb25maWdcbmNvbnN0IGRlZmF1bHRDb25maWcgPSBtZXJnZU9iamVjdHMoe1xuICAgIC8vIGV2ZW50c1xuICAgIG9uTG9hZGluZ1Nsb3c6IG5vb3AsXG4gICAgb25TdWNjZXNzOiBub29wLFxuICAgIG9uRXJyb3I6IG5vb3AsXG4gICAgb25FcnJvclJldHJ5LFxuICAgIG9uRGlzY2FyZGVkOiBub29wLFxuICAgIC8vIHN3aXRjaGVzXG4gICAgcmV2YWxpZGF0ZU9uRm9jdXM6IHRydWUsXG4gICAgcmV2YWxpZGF0ZU9uUmVjb25uZWN0OiB0cnVlLFxuICAgIHJldmFsaWRhdGVJZlN0YWxlOiB0cnVlLFxuICAgIHNob3VsZFJldHJ5T25FcnJvcjogdHJ1ZSxcbiAgICAvLyB0aW1lb3V0c1xuICAgIGVycm9yUmV0cnlJbnRlcnZhbDogc2xvd0Nvbm5lY3Rpb24gPyAxMDAwMCA6IDUwMDAsXG4gICAgZm9jdXNUaHJvdHRsZUludGVydmFsOiA1ICogMTAwMCxcbiAgICBkZWR1cGluZ0ludGVydmFsOiAyICogMTAwMCxcbiAgICBsb2FkaW5nVGltZW91dDogc2xvd0Nvbm5lY3Rpb24gPyA1MDAwIDogMzAwMCxcbiAgICAvLyBwcm92aWRlcnNcbiAgICBjb21wYXJlLFxuICAgIGlzUGF1c2VkOiAoKT0+ZmFsc2UsXG4gICAgY2FjaGUsXG4gICAgbXV0YXRlLFxuICAgIGZhbGxiYWNrOiB7fVxufSwgLy8gdXNlIHdlYiBwcmVzZXQgYnkgZGVmYXVsdFxucHJlc2V0KTtcblxuY29uc3QgbWVyZ2VDb25maWdzID0gKGEsIGIpPT57XG4gICAgLy8gTmVlZCB0byBjcmVhdGUgYSBuZXcgb2JqZWN0IHRvIGF2b2lkIG11dGF0aW5nIHRoZSBvcmlnaW5hbCBoZXJlLlxuICAgIGNvbnN0IHYgPSBtZXJnZU9iamVjdHMoYSwgYik7XG4gICAgLy8gSWYgdHdvIGNvbmZpZ3MgYXJlIHByb3ZpZGVkLCBtZXJnZSB0aGVpciBgdXNlYCBhbmQgYGZhbGxiYWNrYCBvcHRpb25zLlxuICAgIGlmIChiKSB7XG4gICAgICAgIGNvbnN0IHsgdXNlOiB1MSAsIGZhbGxiYWNrOiBmMSAgfSA9IGE7XG4gICAgICAgIGNvbnN0IHsgdXNlOiB1MiAsIGZhbGxiYWNrOiBmMiAgfSA9IGI7XG4gICAgICAgIGlmICh1MSAmJiB1Mikge1xuICAgICAgICAgICAgdi51c2UgPSB1MS5jb25jYXQodTIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmMSAmJiBmMikge1xuICAgICAgICAgICAgdi5mYWxsYmFjayA9IG1lcmdlT2JqZWN0cyhmMSwgZjIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2O1xufTtcblxuY29uc3QgU1dSQ29uZmlnQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe30pO1xuY29uc3QgU1dSQ29uZmlnID0gKHByb3BzKT0+e1xuICAgIGNvbnN0IHsgdmFsdWUgIH0gPSBwcm9wcztcbiAgICBjb25zdCBwYXJlbnRDb25maWcgPSB1c2VDb250ZXh0KFNXUkNvbmZpZ0NvbnRleHQpO1xuICAgIGNvbnN0IGlzRnVuY3Rpb25hbENvbmZpZyA9IGlzRnVuY3Rpb24odmFsdWUpO1xuICAgIGNvbnN0IGNvbmZpZyA9IHVzZU1lbW8oKCk9PmlzRnVuY3Rpb25hbENvbmZpZyA/IHZhbHVlKHBhcmVudENvbmZpZykgOiB2YWx1ZSwgW1xuICAgICAgICBpc0Z1bmN0aW9uYWxDb25maWcsXG4gICAgICAgIHBhcmVudENvbmZpZyxcbiAgICAgICAgdmFsdWVcbiAgICBdKTtcbiAgICAvLyBFeHRlbmQgcGFyZW50IGNvbnRleHQgdmFsdWVzIGFuZCBtaWRkbGV3YXJlLlxuICAgIGNvbnN0IGV4dGVuZGVkQ29uZmlnID0gdXNlTWVtbygoKT0+aXNGdW5jdGlvbmFsQ29uZmlnID8gY29uZmlnIDogbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKSwgW1xuICAgICAgICBpc0Z1bmN0aW9uYWxDb25maWcsXG4gICAgICAgIHBhcmVudENvbmZpZyxcbiAgICAgICAgY29uZmlnXG4gICAgXSk7XG4gICAgLy8gU2hvdWxkIG5vdCB1c2UgdGhlIGluaGVyaXRlZCBwcm92aWRlci5cbiAgICBjb25zdCBwcm92aWRlciA9IGNvbmZpZyAmJiBjb25maWcucHJvdmlkZXI7XG4gICAgLy8gaW5pdGlhbGl6ZSB0aGUgY2FjaGUgb25seSBvbiBmaXJzdCBhY2Nlc3MuXG4gICAgY29uc3QgY2FjaGVDb250ZXh0UmVmID0gdXNlUmVmKFVOREVGSU5FRCk7XG4gICAgaWYgKHByb3ZpZGVyICYmICFjYWNoZUNvbnRleHRSZWYuY3VycmVudCkge1xuICAgICAgICBjYWNoZUNvbnRleHRSZWYuY3VycmVudCA9IGluaXRDYWNoZShwcm92aWRlcihleHRlbmRlZENvbmZpZy5jYWNoZSB8fCBjYWNoZSksIGNvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlQ29udGV4dCA9IGNhY2hlQ29udGV4dFJlZi5jdXJyZW50O1xuICAgIC8vIE92ZXJyaWRlIHRoZSBjYWNoZSBpZiBhIG5ldyBwcm92aWRlciBpcyBnaXZlbi5cbiAgICBpZiAoY2FjaGVDb250ZXh0KSB7XG4gICAgICAgIGV4dGVuZGVkQ29uZmlnLmNhY2hlID0gY2FjaGVDb250ZXh0WzBdO1xuICAgICAgICBleHRlbmRlZENvbmZpZy5tdXRhdGUgPSBjYWNoZUNvbnRleHRbMV07XG4gICAgfVxuICAgIC8vIFVuc3Vic2NyaWJlIGV2ZW50cy5cbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpPT57XG4gICAgICAgIGlmIChjYWNoZUNvbnRleHQpIHtcbiAgICAgICAgICAgIGNhY2hlQ29udGV4dFsyXSAmJiBjYWNoZUNvbnRleHRbMl0oKTtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZUNvbnRleHRbM107XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoU1dSQ29uZmlnQ29udGV4dC5Qcm92aWRlciwgbWVyZ2VPYmplY3RzKHByb3BzLCB7XG4gICAgICAgIHZhbHVlOiBleHRlbmRlZENvbmZpZ1xuICAgIH0pKTtcbn07XG5cbi8vIEB0cy1leHBlY3QtZXJyb3JcbmNvbnN0IGVuYWJsZURldnRvb2xzID0gaXNXaW5kb3dEZWZpbmVkICYmIHdpbmRvdy5fX1NXUl9ERVZUT09MU19VU0VfXztcbmNvbnN0IHVzZSA9IGVuYWJsZURldnRvb2xzID8gd2luZG93Ll9fU1dSX0RFVlRPT0xTX1VTRV9fIDogW107XG5jb25zdCBzZXR1cERldlRvb2xzID0gKCk9PntcbiAgICBpZiAoZW5hYmxlRGV2dG9vbHMpIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICB3aW5kb3cuX19TV1JfREVWVE9PTFNfUkVBQ1RfXyA9IFJlYWN0O1xuICAgIH1cbn07XG5cbmNvbnN0IG5vcm1hbGl6ZSA9IChhcmdzKT0+e1xuICAgIHJldHVybiBpc0Z1bmN0aW9uKGFyZ3NbMV0pID8gW1xuICAgICAgICBhcmdzWzBdLFxuICAgICAgICBhcmdzWzFdLFxuICAgICAgICBhcmdzWzJdIHx8IHt9XG4gICAgXSA6IFtcbiAgICAgICAgYXJnc1swXSxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgKGFyZ3NbMV0gPT09IG51bGwgPyBhcmdzWzJdIDogYXJnc1sxXSkgfHwge31cbiAgICBdO1xufTtcblxuY29uc3QgdXNlU1dSQ29uZmlnID0gKCk9PntcbiAgICByZXR1cm4gbWVyZ2VPYmplY3RzKGRlZmF1bHRDb25maWcsIHVzZUNvbnRleHQoU1dSQ29uZmlnQ29udGV4dCkpO1xufTtcblxuY29uc3QgcHJlbG9hZCA9IChrZXlfLCBmZXRjaGVyKT0+e1xuICAgIGNvbnN0IFtrZXksIGZuQXJnXSA9IHNlcmlhbGl6ZShrZXlfKTtcbiAgICBjb25zdCBbLCAsICwgUFJFTE9BRF0gPSBTV1JHbG9iYWxTdGF0ZS5nZXQoY2FjaGUpO1xuICAgIC8vIFByZXZlbnQgcHJlbG9hZCB0byBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgYmVmb3JlIHVzZWQuXG4gICAgaWYgKFBSRUxPQURba2V5XSkgcmV0dXJuIFBSRUxPQURba2V5XTtcbiAgICBjb25zdCByZXEgPSBmZXRjaGVyKGZuQXJnKTtcbiAgICBQUkVMT0FEW2tleV0gPSByZXE7XG4gICAgcmV0dXJuIHJlcTtcbn07XG5jb25zdCBtaWRkbGV3YXJlID0gKHVzZVNXUk5leHQpPT4oa2V5XywgZmV0Y2hlcl8sIGNvbmZpZyk9PntcbiAgICAgICAgLy8gZmV0Y2hlciBtaWdodCBiZSBhIHN5bmMgZnVuY3Rpb24sIHNvIHRoaXMgc2hvdWxkIG5vdCBiZSBhbiBhc3luYyBmdW5jdGlvblxuICAgICAgICBjb25zdCBmZXRjaGVyID0gZmV0Y2hlcl8gJiYgKCguLi5hcmdzKT0+e1xuICAgICAgICAgICAgY29uc3QgW2tleV0gPSBzZXJpYWxpemUoa2V5Xyk7XG4gICAgICAgICAgICBjb25zdCBbLCAsICwgUFJFTE9BRF0gPSBTV1JHbG9iYWxTdGF0ZS5nZXQoY2FjaGUpO1xuICAgICAgICAgICAgY29uc3QgcmVxID0gUFJFTE9BRFtrZXldO1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHJlcSkpIHJldHVybiBmZXRjaGVyXyguLi5hcmdzKTtcbiAgICAgICAgICAgIGRlbGV0ZSBQUkVMT0FEW2tleV07XG4gICAgICAgICAgICByZXR1cm4gcmVxO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVzZVNXUk5leHQoa2V5XywgZmV0Y2hlciwgY29uZmlnKTtcbiAgICB9O1xuXG5jb25zdCBCVUlMVF9JTl9NSURETEVXQVJFID0gdXNlLmNvbmNhdChtaWRkbGV3YXJlKTtcblxuLy8gSXQncyB0cmlja3kgdG8gcGFzcyBnZW5lcmljIHR5cGVzIGFzIHBhcmFtZXRlcnMsIHNvIHdlIGp1c3QgZGlyZWN0bHkgb3ZlcnJpZGVcbi8vIHRoZSB0eXBlcyBoZXJlLlxuY29uc3Qgd2l0aEFyZ3MgPSAoaG9vayk9PntcbiAgICByZXR1cm4gZnVuY3Rpb24gdXNlU1dSQXJncyguLi5hcmdzKSB7XG4gICAgICAgIC8vIEdldCB0aGUgZGVmYXVsdCBhbmQgaW5oZXJpdGVkIGNvbmZpZ3VyYXRpb24uXG4gICAgICAgIGNvbnN0IGZhbGxiYWNrQ29uZmlnID0gdXNlU1dSQ29uZmlnKCk7XG4gICAgICAgIC8vIE5vcm1hbGl6ZSBhcmd1bWVudHMuXG4gICAgICAgIGNvbnN0IFtrZXksIGZuLCBfY29uZmlnXSA9IG5vcm1hbGl6ZShhcmdzKTtcbiAgICAgICAgLy8gTWVyZ2UgY29uZmlndXJhdGlvbnMuXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IG1lcmdlQ29uZmlncyhmYWxsYmFja0NvbmZpZywgX2NvbmZpZyk7XG4gICAgICAgIC8vIEFwcGx5IG1pZGRsZXdhcmVcbiAgICAgICAgbGV0IG5leHQgPSBob29rO1xuICAgICAgICBjb25zdCB7IHVzZSAgfSA9IGNvbmZpZztcbiAgICAgICAgY29uc3QgbWlkZGxld2FyZSA9ICh1c2UgfHwgW10pLmNvbmNhdChCVUlMVF9JTl9NSURETEVXQVJFKTtcbiAgICAgICAgZm9yKGxldCBpID0gbWlkZGxld2FyZS5sZW5ndGg7IGktLTspe1xuICAgICAgICAgICAgbmV4dCA9IG1pZGRsZXdhcmVbaV0obmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5leHQoa2V5LCBmbiB8fCBjb25maWcuZmV0Y2hlciB8fCBudWxsLCBjb25maWcpO1xuICAgIH07XG59O1xuXG4vKipcbiAqIEFuIGltcGxlbWVudGF0aW9uIG9mIHN0YXRlIHdpdGggZGVwZW5kZW5jeS10cmFja2luZy5cbiAqLyBjb25zdCB1c2VTdGF0ZVdpdGhEZXBzID0gKHN0YXRlKT0+e1xuICAgIGNvbnN0IHJlcmVuZGVyID0gdXNlU3RhdGUoe30pWzFdO1xuICAgIGNvbnN0IHVubW91bnRlZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3Qgc3RhdGVSZWYgPSB1c2VSZWYoc3RhdGUpO1xuICAgIC8vIElmIGEgc3RhdGUgcHJvcGVydHkgKGRhdGEsIGVycm9yLCBvciBpc1ZhbGlkYXRpbmcpIGlzIGFjY2Vzc2VkIGJ5IHRoZSByZW5kZXJcbiAgICAvLyBmdW5jdGlvbiwgd2UgbWFyayB0aGUgcHJvcGVydHkgYXMgYSBkZXBlbmRlbmN5IHNvIGlmIGl0IGlzIHVwZGF0ZWQgYWdhaW5cbiAgICAvLyBpbiB0aGUgZnV0dXJlLCB3ZSB0cmlnZ2VyIGEgcmVyZW5kZXIuXG4gICAgLy8gVGhpcyBpcyBhbHNvIGtub3duIGFzIGRlcGVuZGVuY3ktdHJhY2tpbmcuXG4gICAgY29uc3Qgc3RhdGVEZXBlbmRlbmNpZXNSZWYgPSB1c2VSZWYoe1xuICAgICAgICBkYXRhOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6IGZhbHNlLFxuICAgICAgICBpc1ZhbGlkYXRpbmc6IGZhbHNlXG4gICAgfSk7XG4gICAgLyoqXG4gICAqIEBwYXJhbSBwYXlsb2FkIFRvIGNoYW5nZSBzdGF0ZVJlZiwgcGFzcyB0aGUgdmFsdWVzIGV4cGxpY2l0bHkgdG8gc2V0U3RhdGU6XG4gICAqIEBleGFtcGxlXG4gICAqIGBgYGpzXG4gICAqIHNldFN0YXRlKHtcbiAgICogICBpc1ZhbGlkYXRpbmc6IGZhbHNlXG4gICAqICAgZGF0YTogbmV3RGF0YSAvLyBzZXQgZGF0YSB0byBuZXdEYXRhXG4gICAqICAgZXJyb3I6IHVuZGVmaW5lZCAvLyBzZXQgZXJyb3IgdG8gdW5kZWZpbmVkXG4gICAqIH0pXG4gICAqXG4gICAqIHNldFN0YXRlKHtcbiAgICogICBpc1ZhbGlkYXRpbmc6IGZhbHNlXG4gICAqICAgZGF0YTogdW5kZWZpbmVkIC8vIHNldCBkYXRhIHRvIHVuZGVmaW5lZFxuICAgKiAgIGVycm9yOiBlcnIgLy8gc2V0IGVycm9yIHRvIGVyclxuICAgKiB9KVxuICAgKiBgYGBcbiAgICovIGNvbnN0IHNldFN0YXRlID0gdXNlQ2FsbGJhY2soKHBheWxvYWQpPT57XG4gICAgICAgIGxldCBzaG91bGRSZXJlbmRlciA9IGZhbHNlO1xuICAgICAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBzdGF0ZVJlZi5jdXJyZW50O1xuICAgICAgICBmb3IoY29uc3QgXyBpbiBwYXlsb2FkKXtcbiAgICAgICAgICAgIGNvbnN0IGsgPSBfO1xuICAgICAgICAgICAgLy8gSWYgdGhlIHByb3BlcnR5IGhhcyBjaGFuZ2VkLCB1cGRhdGUgdGhlIHN0YXRlIGFuZCBtYXJrIHJlcmVuZGVyIGFzXG4gICAgICAgICAgICAvLyBuZWVkZWQuXG4gICAgICAgICAgICBpZiAoY3VycmVudFN0YXRlW2tdICE9PSBwYXlsb2FkW2tdKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFN0YXRlW2tdID0gcGF5bG9hZFtrXTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgcHJvcGVydHkgaXMgYWNjZXNzZWQgYnkgdGhlIGNvbXBvbmVudCwgYSByZXJlbmRlciBzaG91bGQgYmVcbiAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyZWQuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlRGVwZW5kZW5jaWVzUmVmLmN1cnJlbnRba10pIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkUmVyZW5kZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hvdWxkUmVyZW5kZXIgJiYgIXVubW91bnRlZFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBpZiAoSVNfUkVBQ1RfTEVHQUNZKSB7XG4gICAgICAgICAgICAgICAgcmVyZW5kZXIoe30pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBSZWFjdC5zdGFydFRyYW5zaXRpb24oKCk9PnJlcmVuZGVyKHt9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIHJlcmVuZGVyXG4gICAgXSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKT0+e1xuICAgICAgICB1bm1vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIHVubW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gW1xuICAgICAgICBzdGF0ZVJlZixcbiAgICAgICAgc3RhdGVEZXBlbmRlbmNpZXNSZWYuY3VycmVudCxcbiAgICAgICAgc2V0U3RhdGVcbiAgICBdO1xufTtcblxuLy8gQWRkIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYSBsaXN0IG9mIGtleWVkIGNhbGxiYWNrIGZ1bmN0aW9ucyBhbmQgcmV0dXJuXG4vLyB0aGUgdW5zdWJzY3JpYmUgZnVuY3Rpb24uXG5jb25zdCBzdWJzY3JpYmVDYWxsYmFjayA9IChrZXksIGNhbGxiYWNrcywgY2FsbGJhY2spPT57XG4gICAgY29uc3Qga2V5ZWRSZXZhbGlkYXRvcnMgPSBjYWxsYmFja3Nba2V5XSB8fCAoY2FsbGJhY2tzW2tleV0gPSBbXSk7XG4gICAga2V5ZWRSZXZhbGlkYXRvcnMucHVzaChjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpPT57XG4gICAgICAgIGNvbnN0IGluZGV4ID0ga2V5ZWRSZXZhbGlkYXRvcnMuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAvLyBPKDEpOiBmYXN0ZXIgdGhhbiBzcGxpY2VcbiAgICAgICAgICAgIGtleWVkUmV2YWxpZGF0b3JzW2luZGV4XSA9IGtleWVkUmV2YWxpZGF0b3JzW2tleWVkUmV2YWxpZGF0b3JzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAga2V5ZWRSZXZhbGlkYXRvcnMucG9wKCk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuLy8gQ3JlYXRlIGEgY3VzdG9tIGhvb2sgd2l0aCBhIG1pZGRsZXdhcmVcbmNvbnN0IHdpdGhNaWRkbGV3YXJlID0gKHVzZVNXUiwgbWlkZGxld2FyZSk9PntcbiAgICByZXR1cm4gKC4uLmFyZ3MpPT57XG4gICAgICAgIGNvbnN0IFtrZXksIGZuLCBjb25maWddID0gbm9ybWFsaXplKGFyZ3MpO1xuICAgICAgICBjb25zdCB1c2VzID0gKGNvbmZpZy51c2UgfHwgW10pLmNvbmNhdChtaWRkbGV3YXJlKTtcbiAgICAgICAgcmV0dXJuIHVzZVNXUihrZXksIGZuLCB7XG4gICAgICAgICAgICAuLi5jb25maWcsXG4gICAgICAgICAgICB1c2U6IHVzZXNcbiAgICAgICAgfSk7XG4gICAgfTtcbn07XG5cbnNldHVwRGV2VG9vbHMoKTtcblxuZXhwb3J0IHsgSVNfUkVBQ1RfTEVHQUNZLCBJU19TRVJWRVIsIE9CSkVDVCwgU1dSQ29uZmlnLCBTV1JHbG9iYWxTdGF0ZSwgVU5ERUZJTkVELCBjYWNoZSwgY29tcGFyZSwgY3JlYXRlQ2FjaGVIZWxwZXIsIGRlZmF1bHRDb25maWcsIGRlZmF1bHRDb25maWdPcHRpb25zLCBnZXRUaW1lc3RhbXAsIGhhc1JlcXVlc3RBbmltYXRpb25GcmFtZSwgaW5pdENhY2hlLCBpbnRlcm5hbE11dGF0ZSwgaXNEb2N1bWVudERlZmluZWQsIGlzRnVuY3Rpb24sIGlzUHJvbWlzZUxpa2UsIGlzVW5kZWZpbmVkLCBpc1dpbmRvd0RlZmluZWQsIG1lcmdlQ29uZmlncywgbWVyZ2VPYmplY3RzLCBtdXRhdGUsIG5vb3AsIG5vcm1hbGl6ZSwgcHJlbG9hZCwgcHJlc2V0LCByQUYsIGNvbnN0YW50cyBhcyByZXZhbGlkYXRlRXZlbnRzLCBzZXJpYWxpemUsIHNsb3dDb25uZWN0aW9uLCBzdGFibGVIYXNoLCBzdWJzY3JpYmVDYWxsYmFjaywgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCwgdXNlU1dSQ29uZmlnLCB1c2VTdGF0ZVdpdGhEZXBzLCB3aXRoQXJncywgd2l0aE1pZGRsZXdhcmUgfTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlTWVtbyIsInVzZVJlZiIsImNyZWF0ZUVsZW1lbnQiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwibm9vcCIsIlVOREVGSU5FRCIsIk9CSkVDVCIsIk9iamVjdCIsImlzVW5kZWZpbmVkIiwidiIsImlzRnVuY3Rpb24iLCJtZXJnZU9iamVjdHMiLCJhIiwiYiIsImlzUHJvbWlzZUxpa2UiLCJ4IiwidGhlbiIsInRhYmxlIiwiV2Vha01hcCIsImNvdW50ZXIiLCJzdGFibGVIYXNoIiwiYXJnIiwidHlwZSIsImNvbnN0cnVjdG9yIiwiaXNEYXRlIiwiRGF0ZSIsInJlc3VsdCIsImluZGV4IiwiUmVnRXhwIiwiZ2V0Iiwic2V0IiwiQXJyYXkiLCJsZW5ndGgiLCJrZXlzIiwic29ydCIsInBvcCIsInRvSlNPTiIsInRvU3RyaW5nIiwiSlNPTiIsInN0cmluZ2lmeSIsIlNXUkdsb2JhbFN0YXRlIiwiRU1QVFlfQ0FDSEUiLCJJTklUSUFMX0NBQ0hFIiwiU1RSX1VOREVGSU5FRCIsImlzV2luZG93RGVmaW5lZCIsImlzRG9jdW1lbnREZWZpbmVkIiwiZG9jdW1lbnQiLCJoYXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ3aW5kb3ciLCJjcmVhdGVDYWNoZUhlbHBlciIsImNhY2hlIiwia2V5Iiwic3RhdGUiLCJpbmZvIiwicHJldiIsIm9ubGluZSIsImlzT25saW5lIiwib25XaW5kb3dFdmVudCIsIm9mZldpbmRvd0V2ZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsImJpbmQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaXNWaXNpYmxlIiwidmlzaWJpbGl0eVN0YXRlIiwiaW5pdEZvY3VzIiwiY2FsbGJhY2siLCJpbml0UmVjb25uZWN0Iiwib25PbmxpbmUiLCJvbk9mZmxpbmUiLCJwcmVzZXQiLCJkZWZhdWx0Q29uZmlnT3B0aW9ucyIsIklTX1JFQUNUX0xFR0FDWSIsInVzZUlkIiwiSVNfU0VSVkVSIiwickFGIiwiZiIsInNldFRpbWVvdXQiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwibmF2aWdhdG9yQ29ubmVjdGlvbiIsIm5hdmlnYXRvciIsImNvbm5lY3Rpb24iLCJzbG93Q29ubmVjdGlvbiIsImluY2x1ZGVzIiwiZWZmZWN0aXZlVHlwZSIsInNhdmVEYXRhIiwic2VyaWFsaXplIiwiZXJyIiwiYXJncyIsImlzQXJyYXkiLCJfX3RpbWVzdGFtcCIsImdldFRpbWVzdGFtcCIsIkZPQ1VTX0VWRU5UIiwiUkVDT05ORUNUX0VWRU5UIiwiTVVUQVRFX0VWRU5UIiwiRVJST1JfUkVWQUxJREFURV9FVkVOVCIsImNvbnN0YW50cyIsIl9fcHJvdG9fXyIsImludGVybmFsTXV0YXRlIiwiX2tleSIsIl9kYXRhIiwiX29wdHMiLCJvcHRpb25zIiwicG9wdWxhdGVDYWNoZSIsInRocm93T25FcnJvciIsInJldmFsaWRhdGUiLCJyb2xsYmFja09uRXJyb3JPcHRpb24iLCJyb2xsYmFja09uRXJyb3IiLCJvcHRpbWlzdGljRGF0YSIsImVycm9yIiwia2V5RmlsdGVyIiwibWF0Y2hlZEtleXMiLCJpdCIsInRlc3QiLCJfayIsInB1c2giLCJQcm9taXNlIiwiYWxsIiwibWFwIiwibXV0YXRlQnlLZXkiLCJFVkVOVF9SRVZBTElEQVRPUlMiLCJNVVRBVElPTiIsIkZFVENIIiwiUFJFTE9BRCIsInJldmFsaWRhdG9ycyIsInN0YXJ0UmV2YWxpZGF0ZSIsImRhdGEiLCJiZWZvcmVNdXRhdGlvblRzIiwiaGFzT3B0aW1pc3RpY0RhdGEiLCJkaXNwbGF5ZWREYXRhIiwiY3VycmVudERhdGEiLCJfYyIsImNvbW1pdHRlZERhdGEiLCJjYXRjaCIsInJlcyIsInJldmFsaWRhdGVBbGxLZXlzIiwiaW5pdENhY2hlIiwicHJvdmlkZXIiLCJoYXMiLCJvcHRzIiwibXV0YXRlIiwidW5tb3VudCIsInN1YnNjcmlwdGlvbnMiLCJzdWJzY3JpYmUiLCJzdWJzIiwic3BsaWNlIiwiaW5kZXhPZiIsInNldHRlciIsInZhbHVlIiwiZm4iLCJpbml0UHJvdmlkZXIiLCJyZWxlYXNlRm9jdXMiLCJyZWxlYXNlUmVjb25uZWN0IiwiZGVsZXRlIiwib25FcnJvclJldHJ5IiwiXyIsIl9fIiwiY29uZmlnIiwibWF4UmV0cnlDb3VudCIsImVycm9yUmV0cnlDb3VudCIsImN1cnJlbnRSZXRyeUNvdW50IiwicmV0cnlDb3VudCIsInRpbWVvdXQiLCJNYXRoIiwicmFuZG9tIiwiZXJyb3JSZXRyeUludGVydmFsIiwiY29tcGFyZSIsIm5ld0RhdGEiLCJNYXAiLCJkZWZhdWx0Q29uZmlnIiwib25Mb2FkaW5nU2xvdyIsIm9uU3VjY2VzcyIsIm9uRXJyb3IiLCJvbkRpc2NhcmRlZCIsInJldmFsaWRhdGVPbkZvY3VzIiwicmV2YWxpZGF0ZU9uUmVjb25uZWN0IiwicmV2YWxpZGF0ZUlmU3RhbGUiLCJzaG91bGRSZXRyeU9uRXJyb3IiLCJmb2N1c1Rocm90dGxlSW50ZXJ2YWwiLCJkZWR1cGluZ0ludGVydmFsIiwibG9hZGluZ1RpbWVvdXQiLCJpc1BhdXNlZCIsImZhbGxiYWNrIiwibWVyZ2VDb25maWdzIiwidXNlIiwidTEiLCJmMSIsInUyIiwiZjIiLCJjb25jYXQiLCJTV1JDb25maWdDb250ZXh0IiwiU1dSQ29uZmlnIiwicHJvcHMiLCJwYXJlbnRDb25maWciLCJpc0Z1bmN0aW9uYWxDb25maWciLCJleHRlbmRlZENvbmZpZyIsImNhY2hlQ29udGV4dFJlZiIsImN1cnJlbnQiLCJjYWNoZUNvbnRleHQiLCJQcm92aWRlciIsImVuYWJsZURldnRvb2xzIiwiX19TV1JfREVWVE9PTFNfVVNFX18iLCJzZXR1cERldlRvb2xzIiwiX19TV1JfREVWVE9PTFNfUkVBQ1RfXyIsIm5vcm1hbGl6ZSIsInVzZVNXUkNvbmZpZyIsInByZWxvYWQiLCJrZXlfIiwiZmV0Y2hlciIsImZuQXJnIiwicmVxIiwibWlkZGxld2FyZSIsInVzZVNXUk5leHQiLCJmZXRjaGVyXyIsIkJVSUxUX0lOX01JRERMRVdBUkUiLCJ3aXRoQXJncyIsImhvb2siLCJ1c2VTV1JBcmdzIiwiZmFsbGJhY2tDb25maWciLCJfY29uZmlnIiwibmV4dCIsImkiLCJ1c2VTdGF0ZVdpdGhEZXBzIiwicmVyZW5kZXIiLCJ1bm1vdW50ZWRSZWYiLCJzdGF0ZVJlZiIsInN0YXRlRGVwZW5kZW5jaWVzUmVmIiwiaXNWYWxpZGF0aW5nIiwic2V0U3RhdGUiLCJwYXlsb2FkIiwic2hvdWxkUmVyZW5kZXIiLCJjdXJyZW50U3RhdGUiLCJrIiwic3RhcnRUcmFuc2l0aW9uIiwic3Vic2NyaWJlQ2FsbGJhY2siLCJjYWxsYmFja3MiLCJrZXllZFJldmFsaWRhdG9ycyIsIndpdGhNaWRkbGV3YXJlIiwidXNlU1dSIiwidXNlcyIsInJldmFsaWRhdGVFdmVudHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swr/_internal/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/swr/core/dist/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/swr/core/dist/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SWRConfig: () => (/* binding */ SWRConfig),\n/* harmony export */   \"default\": () => (/* binding */ useSWR),\n/* harmony export */   mutate: () => (/* reexport safe */ swr_internal__WEBPACK_IMPORTED_MODULE_2__.mutate),\n/* harmony export */   preload: () => (/* reexport safe */ swr_internal__WEBPACK_IMPORTED_MODULE_2__.preload),\n/* harmony export */   unstable_serialize: () => (/* binding */ unstable_serialize),\n/* harmony export */   useSWRConfig: () => (/* reexport safe */ swr_internal__WEBPACK_IMPORTED_MODULE_2__.useSWRConfig)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! use-sync-external-store/shim/index.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/index.js\");\n/* harmony import */ var swr_internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! swr/_internal */ \"(ssr)/./node_modules/swr/_internal/dist/index.mjs\");\n\n\n\n\nconst unstable_serialize = (key)=>(0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.serialize)(key)[0];\n/// <reference types=\"react/experimental\" />\nconst use = (react__WEBPACK_IMPORTED_MODULE_0___default().use) || ((promise)=>{\n    if (promise.status === \"pending\") {\n        throw promise;\n    } else if (promise.status === \"fulfilled\") {\n        return promise.value;\n    } else if (promise.status === \"rejected\") {\n        throw promise.reason;\n    } else {\n        promise.status = \"pending\";\n        promise.then((v)=>{\n            promise.status = \"fulfilled\";\n            promise.value = v;\n        }, (e)=>{\n            promise.status = \"rejected\";\n            promise.reason = e;\n        });\n        throw promise;\n    }\n});\nconst WITH_DEDUPE = {\n    dedupe: true\n};\nconst useSWRHandler = (_key, fetcher, config)=>{\n    const { cache, compare, suspense, fallbackData, revalidateOnMount, revalidateIfStale, refreshInterval, refreshWhenHidden, refreshWhenOffline, keepPreviousData } = config;\n    const [EVENT_REVALIDATORS, MUTATION, FETCH, PRELOAD] = swr_internal__WEBPACK_IMPORTED_MODULE_2__.SWRGlobalState.get(cache);\n    // `key` is the identifier of the SWR internal state,\n    // `fnArg` is the argument/arguments parsed from the key, which will be passed\n    // to the fetcher.\n    // All of them are derived from `_key`.\n    const [key, fnArg] = (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.serialize)(_key);\n    // If it's the initial render of this hook.\n    const initialMountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // If the hook is unmounted already. This will be used to prevent some effects\n    // to be called after unmounting.\n    const unmountedRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    // Refs to keep the key and config.\n    const keyRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(key);\n    const fetcherRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(fetcher);\n    const configRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(config);\n    const getConfig = ()=>configRef.current;\n    const isActive = ()=>getConfig().isVisible() && getConfig().isOnline();\n    const [getCache, setCache, subscribeCache, getInitialCache] = (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.createCacheHelper)(cache, key);\n    const stateDependencies = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({}).current;\n    const fallback = (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(fallbackData) ? config.fallback[key] : fallbackData;\n    const isEqual = (prev, current)=>{\n        for(const _ in stateDependencies){\n            const t = _;\n            if (t === \"data\") {\n                if (!compare(prev[t], current[t])) {\n                    if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(prev[t])) {\n                        return false;\n                    }\n                    if (!compare(returnedData, current[t])) {\n                        return false;\n                    }\n                }\n            } else {\n                if (current[t] !== prev[t]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    };\n    const getSnapshot = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(()=>{\n        const shouldStartRequest = (()=>{\n            if (!key) return false;\n            if (!fetcher) return false;\n            // If `revalidateOnMount` is set, we take the value directly.\n            if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(revalidateOnMount)) return revalidateOnMount;\n            // If it's paused, we skip revalidation.\n            if (getConfig().isPaused()) return false;\n            if (suspense) return false;\n            if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(revalidateIfStale)) return revalidateIfStale;\n            return true;\n        })();\n        // Get the cache and merge it with expected states.\n        const getSelectedCache = (state)=>{\n            // We only select the needed fields from the state.\n            const snapshot = (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.mergeObjects)(state);\n            delete snapshot._k;\n            if (!shouldStartRequest) {\n                return snapshot;\n            }\n            return {\n                isValidating: true,\n                isLoading: true,\n                ...snapshot\n            };\n        };\n        const cachedData = getCache();\n        const initialData = getInitialCache();\n        const clientSnapshot = getSelectedCache(cachedData);\n        const serverSnapshot = cachedData === initialData ? clientSnapshot : getSelectedCache(initialData);\n        // To make sure that we are returning the same object reference to avoid\n        // unnecessary re-renders, we keep the previous snapshot and use deep\n        // comparison to check if we need to return a new one.\n        let memorizedSnapshot = clientSnapshot;\n        return [\n            ()=>{\n                const newSnapshot = getSelectedCache(getCache());\n                const compareResult = isEqual(newSnapshot, memorizedSnapshot);\n                if (compareResult) {\n                    // Mentally, we should always return the `memorizedSnapshot` here\n                    // as there's no change between the new and old snapshots.\n                    // However, since the `isEqual` function only compares selected fields,\n                    // the values of the unselected fields might be changed. That's\n                    // simply because we didn't track them.\n                    // To support the case in https://github.com/vercel/swr/pull/2576,\n                    // we need to update these fields in the `memorizedSnapshot` too\n                    // with direct mutations to ensure the snapshot is always up-to-date\n                    // even for the unselected fields, but only trigger re-renders when\n                    // the selected fields are changed.\n                    memorizedSnapshot.data = newSnapshot.data;\n                    memorizedSnapshot.isLoading = newSnapshot.isLoading;\n                    memorizedSnapshot.isValidating = newSnapshot.isValidating;\n                    memorizedSnapshot.error = newSnapshot.error;\n                    return memorizedSnapshot;\n                } else {\n                    memorizedSnapshot = newSnapshot;\n                    return newSnapshot;\n                }\n            },\n            ()=>serverSnapshot\n        ];\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        cache,\n        key\n    ]);\n    // Get the current state that SWR should return.\n    const cached = (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_1__.useSyncExternalStore)((0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((callback)=>subscribeCache(key, (current, prev)=>{\n            if (!isEqual(prev, current)) callback();\n        }), [\n        cache,\n        key\n    ]), getSnapshot[0], getSnapshot[1]);\n    const isInitialMount = !initialMountedRef.current;\n    const hasRevalidator = EVENT_REVALIDATORS[key] && EVENT_REVALIDATORS[key].length > 0;\n    const cachedData = cached.data;\n    const data = (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(cachedData) ? fallback : cachedData;\n    const error = cached.error;\n    // Use a ref to store previously returned data. Use the initial data as its initial value.\n    const laggyDataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(data);\n    const returnedData = keepPreviousData ? (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(cachedData) ? laggyDataRef.current : cachedData : data;\n    // - Suspense mode and there's stale data for the initial render.\n    // - Not suspense mode and there is no fallback data and `revalidateIfStale` is enabled.\n    // - `revalidateIfStale` is enabled but `data` is not defined.\n    const shouldDoInitialRevalidation = (()=>{\n        // if a key already has revalidators and also has error, we should not trigger revalidation\n        if (hasRevalidator && !(0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(error)) return false;\n        // If `revalidateOnMount` is set, we take the value directly.\n        if (isInitialMount && !(0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(revalidateOnMount)) return revalidateOnMount;\n        // If it's paused, we skip revalidation.\n        if (getConfig().isPaused()) return false;\n        // Under suspense mode, it will always fetch on render if there is no\n        // stale data so no need to revalidate immediately mount it again.\n        // If data exists, only revalidate if `revalidateIfStale` is true.\n        if (suspense) return (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(data) ? false : revalidateIfStale;\n        // If there is no stale data, we need to revalidate when mount;\n        // If `revalidateIfStale` is set to true, we will always revalidate.\n        return (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(data) || revalidateIfStale;\n    })();\n    // Resolve the default validating state:\n    // If it's able to validate, and it should revalidate when mount, this will be true.\n    const defaultValidatingState = !!(key && fetcher && isInitialMount && shouldDoInitialRevalidation);\n    const isValidating = (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(cached.isValidating) ? defaultValidatingState : cached.isValidating;\n    const isLoading = (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(cached.isLoading) ? defaultValidatingState : cached.isLoading;\n    // The revalidation function is a carefully crafted wrapper of the original\n    // `fetcher`, to correctly handle the many edge cases.\n    const revalidate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (revalidateOpts)=>{\n        const currentFetcher = fetcherRef.current;\n        if (!key || !currentFetcher || unmountedRef.current || getConfig().isPaused()) {\n            return false;\n        }\n        let newData;\n        let startAt;\n        let loading = true;\n        const opts = revalidateOpts || {};\n        // If there is no ongoing concurrent request, or `dedupe` is not set, a\n        // new request should be initiated.\n        const shouldStartNewRequest = !FETCH[key] || !opts.dedupe;\n        /*\n         For React 17\n         Do unmount check for calls:\n         If key has changed during the revalidation, or the component has been\n         unmounted, old dispatch and old event callbacks should not take any\n         effect\n\n        For React 18\n        only check if key has changed\n        https://github.com/reactwg/react-18/discussions/82\n      */ const callbackSafeguard = ()=>{\n            if (swr_internal__WEBPACK_IMPORTED_MODULE_2__.IS_REACT_LEGACY) {\n                return !unmountedRef.current && key === keyRef.current && initialMountedRef.current;\n            }\n            return key === keyRef.current;\n        };\n        // The final state object when the request finishes.\n        const finalState = {\n            isValidating: false,\n            isLoading: false\n        };\n        const finishRequestAndUpdateState = ()=>{\n            setCache(finalState);\n        };\n        const cleanupState = ()=>{\n            // Check if it's still the same request before deleting it.\n            const requestInfo = FETCH[key];\n            if (requestInfo && requestInfo[1] === startAt) {\n                delete FETCH[key];\n            }\n        };\n        // Start fetching. Change the `isValidating` state, update the cache.\n        const initialState = {\n            isValidating: true\n        };\n        // It is in the `isLoading` state, if and only if there is no cached data.\n        // This bypasses fallback data and laggy data.\n        if ((0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(getCache().data)) {\n            initialState.isLoading = true;\n        }\n        try {\n            if (shouldStartNewRequest) {\n                setCache(initialState);\n                // If no cache is being rendered currently (it shows a blank page),\n                // we trigger the loading slow event.\n                if (config.loadingTimeout && (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(getCache().data)) {\n                    setTimeout(()=>{\n                        if (loading && callbackSafeguard()) {\n                            getConfig().onLoadingSlow(key, config);\n                        }\n                    }, config.loadingTimeout);\n                }\n                // Start the request and save the timestamp.\n                // Key must be truthy if entering here.\n                FETCH[key] = [\n                    currentFetcher(fnArg),\n                    (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.getTimestamp)()\n                ];\n            }\n            [newData, startAt] = FETCH[key];\n            newData = await newData;\n            if (shouldStartNewRequest) {\n                // If the request isn't interrupted, clean it up after the\n                // deduplication interval.\n                setTimeout(cleanupState, config.dedupingInterval);\n            }\n            // If there're other ongoing request(s), started after the current one,\n            // we need to ignore the current one to avoid possible race conditions:\n            //   req1------------------>res1        (current one)\n            //        req2---------------->res2\n            // the request that fired later will always be kept.\n            // The timestamp maybe be `undefined` or a number\n            if (!FETCH[key] || FETCH[key][1] !== startAt) {\n                if (shouldStartNewRequest) {\n                    if (callbackSafeguard()) {\n                        getConfig().onDiscarded(key);\n                    }\n                }\n                return false;\n            }\n            // Clear error.\n            finalState.error = swr_internal__WEBPACK_IMPORTED_MODULE_2__.UNDEFINED;\n            // If there're other mutations(s), that overlapped with the current revalidation:\n            // case 1:\n            //   req------------------>res\n            //       mutate------>end\n            // case 2:\n            //         req------------>res\n            //   mutate------>end\n            // case 3:\n            //   req------------------>res\n            //       mutate-------...---------->\n            // we have to ignore the revalidation result (res) because it's no longer fresh.\n            // meanwhile, a new revalidation should be triggered when the mutation ends.\n            const mutationInfo = MUTATION[key];\n            if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(mutationInfo) && // case 1\n            (startAt <= mutationInfo[0] || // case 2\n            startAt <= mutationInfo[1] || // case 3\n            mutationInfo[1] === 0)) {\n                finishRequestAndUpdateState();\n                if (shouldStartNewRequest) {\n                    if (callbackSafeguard()) {\n                        getConfig().onDiscarded(key);\n                    }\n                }\n                return false;\n            }\n            // Deep compare with the latest state to avoid extra re-renders.\n            // For local state, compare and assign.\n            const cacheData = getCache().data;\n            // Since the compare fn could be custom fn\n            // cacheData might be different from newData even when compare fn returns True\n            finalState.data = compare(cacheData, newData) ? cacheData : newData;\n            // Trigger the successful callback if it's the original request.\n            if (shouldStartNewRequest) {\n                if (callbackSafeguard()) {\n                    getConfig().onSuccess(newData, key, config);\n                }\n            }\n        } catch (err) {\n            cleanupState();\n            const currentConfig = getConfig();\n            const { shouldRetryOnError } = currentConfig;\n            // Not paused, we continue handling the error. Otherwise, discard it.\n            if (!currentConfig.isPaused()) {\n                // Get a new error, don't use deep comparison for errors.\n                finalState.error = err;\n                // Error event and retry logic. Only for the actual request, not\n                // deduped ones.\n                if (shouldStartNewRequest && callbackSafeguard()) {\n                    currentConfig.onError(err, key, currentConfig);\n                    if (shouldRetryOnError === true || (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isFunction)(shouldRetryOnError) && shouldRetryOnError(err)) {\n                        if (isActive()) {\n                            // If it's inactive, stop. It will auto-revalidate when\n                            // refocusing or reconnecting.\n                            // When retrying, deduplication is always enabled.\n                            currentConfig.onErrorRetry(err, key, currentConfig, (_opts)=>{\n                                const revalidators = EVENT_REVALIDATORS[key];\n                                if (revalidators && revalidators[0]) {\n                                    revalidators[0](swr_internal__WEBPACK_IMPORTED_MODULE_2__.revalidateEvents.ERROR_REVALIDATE_EVENT, _opts);\n                                }\n                            }, {\n                                retryCount: (opts.retryCount || 0) + 1,\n                                dedupe: true\n                            });\n                        }\n                    }\n                }\n            }\n        }\n        // Mark loading as stopped.\n        loading = false;\n        // Update the current hook's state.\n        finishRequestAndUpdateState();\n        return true;\n    }, // `keyValidating` are depending on `key`, so we can exclude them from\n    // the deps array.\n    //\n    // FIXME:\n    // `fn` and `config` might be changed during the lifecycle,\n    // but they might be changed every render like this.\n    // `useSWR('key', () => fetch('/api/'), { suspense: true })`\n    // So we omit the values from the deps array\n    // even though it might cause unexpected behaviors.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        key,\n        cache\n    ]);\n    // Similar to the global mutate but bound to the current cache and key.\n    // `cache` isn't allowed to change during the lifecycle.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    const boundMutate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((...args)=>{\n        return (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.internalMutate)(cache, keyRef.current, ...args);\n    }, []);\n    // The logic for updating refs.\n    (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        fetcherRef.current = fetcher;\n        configRef.current = config;\n        // Handle laggy data updates. If there's cached data of the current key,\n        // it'll be the correct reference.\n        if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(cachedData)) {\n            laggyDataRef.current = cachedData;\n        }\n    });\n    // After mounted or key changed.\n    (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        if (!key) return;\n        const softRevalidate = revalidate.bind(swr_internal__WEBPACK_IMPORTED_MODULE_2__.UNDEFINED, WITH_DEDUPE);\n        // Expose revalidators to global event listeners. So we can trigger\n        // revalidation from the outside.\n        let nextFocusRevalidatedAt = 0;\n        const onRevalidate = (type, opts = {})=>{\n            if (type == swr_internal__WEBPACK_IMPORTED_MODULE_2__.revalidateEvents.FOCUS_EVENT) {\n                const now = Date.now();\n                if (getConfig().revalidateOnFocus && now > nextFocusRevalidatedAt && isActive()) {\n                    nextFocusRevalidatedAt = now + getConfig().focusThrottleInterval;\n                    softRevalidate();\n                }\n            } else if (type == swr_internal__WEBPACK_IMPORTED_MODULE_2__.revalidateEvents.RECONNECT_EVENT) {\n                if (getConfig().revalidateOnReconnect && isActive()) {\n                    softRevalidate();\n                }\n            } else if (type == swr_internal__WEBPACK_IMPORTED_MODULE_2__.revalidateEvents.MUTATE_EVENT) {\n                return revalidate();\n            } else if (type == swr_internal__WEBPACK_IMPORTED_MODULE_2__.revalidateEvents.ERROR_REVALIDATE_EVENT) {\n                return revalidate(opts);\n            }\n            return;\n        };\n        const unsubEvents = (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.subscribeCallback)(key, EVENT_REVALIDATORS, onRevalidate);\n        // Mark the component as mounted and update corresponding refs.\n        unmountedRef.current = false;\n        keyRef.current = key;\n        initialMountedRef.current = true;\n        // Keep the original key in the cache.\n        setCache({\n            _k: fnArg\n        });\n        // Trigger a revalidation\n        if (shouldDoInitialRevalidation) {\n            if ((0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(data) || swr_internal__WEBPACK_IMPORTED_MODULE_2__.IS_SERVER) {\n                // Revalidate immediately.\n                softRevalidate();\n            } else {\n                // Delay the revalidate if we have data to return so we won't block\n                // rendering.\n                (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.rAF)(softRevalidate);\n            }\n        }\n        return ()=>{\n            // Mark it as unmounted.\n            unmountedRef.current = true;\n            unsubEvents();\n        };\n    }, [\n        key\n    ]);\n    // Polling\n    (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n        let timer;\n        function next() {\n            // Use the passed interval\n            // ...or invoke the function with the updated data to get the interval\n            const interval = (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isFunction)(refreshInterval) ? refreshInterval(getCache().data) : refreshInterval;\n            // We only start the next interval if `refreshInterval` is not 0, and:\n            // - `force` is true, which is the start of polling\n            // - or `timer` is not 0, which means the effect wasn't canceled\n            if (interval && timer !== -1) {\n                timer = setTimeout(execute, interval);\n            }\n        }\n        function execute() {\n            // Check if it's OK to execute:\n            // Only revalidate when the page is visible, online, and not errored.\n            if (!getCache().error && (refreshWhenHidden || getConfig().isVisible()) && (refreshWhenOffline || getConfig().isOnline())) {\n                revalidate(WITH_DEDUPE).then(next);\n            } else {\n                // Schedule the next interval to check again.\n                next();\n            }\n        }\n        next();\n        return ()=>{\n            if (timer) {\n                clearTimeout(timer);\n                timer = -1;\n            }\n        };\n    }, [\n        refreshInterval,\n        refreshWhenHidden,\n        refreshWhenOffline,\n        key\n    ]);\n    // Display debug info in React DevTools.\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(returnedData);\n    // In Suspense mode, we can't return the empty `data` state.\n    // If there is an `error`, the `error` needs to be thrown to the error boundary.\n    // If there is no `error`, the `revalidation` promise needs to be thrown to\n    // the suspense boundary.\n    if (suspense && (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(data) && key) {\n        // SWR should throw when trying to use Suspense on the server with React 18,\n        // without providing any initial data. See:\n        // https://github.com/vercel/swr/issues/1832\n        if (!swr_internal__WEBPACK_IMPORTED_MODULE_2__.IS_REACT_LEGACY && swr_internal__WEBPACK_IMPORTED_MODULE_2__.IS_SERVER) {\n            throw new Error(\"Fallback data is required when using suspense in SSR.\");\n        }\n        // Always update fetcher and config refs even with the Suspense mode.\n        fetcherRef.current = fetcher;\n        configRef.current = config;\n        unmountedRef.current = false;\n        const req = PRELOAD[key];\n        if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(req)) {\n            const promise = boundMutate(req);\n            use(promise);\n        }\n        if ((0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(error)) {\n            const promise = revalidate(WITH_DEDUPE);\n            if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(returnedData)) {\n                promise.status = \"fulfilled\";\n                promise.value = true;\n            }\n            use(promise);\n        } else {\n            throw error;\n        }\n    }\n    return {\n        mutate: boundMutate,\n        get data () {\n            stateDependencies.data = true;\n            return returnedData;\n        },\n        get error () {\n            stateDependencies.error = true;\n            return error;\n        },\n        get isValidating () {\n            stateDependencies.isValidating = true;\n            return isValidating;\n        },\n        get isLoading () {\n            stateDependencies.isLoading = true;\n            return isLoading;\n        }\n    };\n};\nconst SWRConfig = swr_internal__WEBPACK_IMPORTED_MODULE_2__.OBJECT.defineProperty(swr_internal__WEBPACK_IMPORTED_MODULE_2__.SWRConfig, \"defaultValue\", {\n    value: swr_internal__WEBPACK_IMPORTED_MODULE_2__.defaultConfig\n});\n/**\n * A hook to fetch data.\n *\n * @link https://swr.vercel.app\n * @example\n * ```jsx\n * import useSWR from 'swr'\n * function Profile() {\n *   const { data, error } = useSWR('/api/user', fetcher)\n *   if (error) return <div>failed to load</div>\n *   if (!data) return <div>loading...</div>\n *   return <div>hello {data.name}!</div>\n * }\n * ```\n */ const useSWR = (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.withArgs)(useSWRHandler);\n// useSWR\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dyL2NvcmUvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFrRjtBQUNMO0FBQzRPO0FBQzNQO0FBRTlELE1BQU02QixxQkFBcUIsQ0FBQ0MsTUFBTXhCLHVEQUFTQSxDQUFDd0IsSUFBSSxDQUFDLEVBQUU7QUFFbkQsNENBQTRDO0FBQzVDLE1BQU1DLE1BQU0vQixrREFBZ0IsSUFBSyxFQUFDZ0M7SUFDOUIsSUFBSUEsUUFBUUMsTUFBTSxLQUFLLFdBQVc7UUFDOUIsTUFBTUQ7SUFDVixPQUFPLElBQUlBLFFBQVFDLE1BQU0sS0FBSyxhQUFhO1FBQ3ZDLE9BQU9ELFFBQVFFLEtBQUs7SUFDeEIsT0FBTyxJQUFJRixRQUFRQyxNQUFNLEtBQUssWUFBWTtRQUN0QyxNQUFNRCxRQUFRRyxNQUFNO0lBQ3hCLE9BQU87UUFDSEgsUUFBUUMsTUFBTSxHQUFHO1FBQ2pCRCxRQUFRSSxJQUFJLENBQUMsQ0FBQ0M7WUFDVkwsUUFBUUMsTUFBTSxHQUFHO1lBQ2pCRCxRQUFRRSxLQUFLLEdBQUdHO1FBQ3BCLEdBQUcsQ0FBQ0M7WUFDQU4sUUFBUUMsTUFBTSxHQUFHO1lBQ2pCRCxRQUFRRyxNQUFNLEdBQUdHO1FBQ3JCO1FBQ0EsTUFBTU47SUFDVjtBQUNKO0FBQ0EsTUFBTU8sY0FBYztJQUNoQkMsUUFBUTtBQUNaO0FBQ0EsTUFBTUMsZ0JBQWdCLENBQUNDLE1BQU1DLFNBQVNDO0lBQ2xDLE1BQU0sRUFBRUMsS0FBSyxFQUFHQyxPQUFPLEVBQUdDLFFBQVEsRUFBR0MsWUFBWSxFQUFHQyxpQkFBaUIsRUFBR0MsaUJBQWlCLEVBQUdDLGVBQWUsRUFBR0MsaUJBQWlCLEVBQUdDLGtCQUFrQixFQUFHQyxnQkFBZ0IsRUFBRyxHQUFHVjtJQUM3SyxNQUFNLENBQUNXLG9CQUFvQkMsVUFBVUMsT0FBT0MsUUFBUSxHQUFHOUMsd0RBQWNBLENBQUMrQyxHQUFHLENBQUNkO0lBQzFFLHFEQUFxRDtJQUNyRCw4RUFB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QUN2QixNQUFNOEYsTUFBTXZHLE9BQU8sQ0FBQzVCLElBQUk7UUFDeEIsSUFBSSxDQUFDaEIseURBQVdBLENBQUNtSixNQUFNO1lBQ25CLE1BQU1qSSxVQUFVMkcsWUFBWXNCO1lBQzVCbEksSUFBSUM7UUFDUjtRQUNBLElBQUlsQix5REFBV0EsQ0FBQ3FGLFFBQVE7WUFDcEIsTUFBTW5FLFVBQVU0RSxXQUFXckU7WUFDM0IsSUFBSSxDQUFDekIseURBQVdBLENBQUNtRSxlQUFlO2dCQUM1QmpELFFBQVFDLE1BQU0sR0FBRztnQkFDakJELFFBQVFFLEtBQUssR0FBRztZQUNwQjtZQUNBSCxJQUFJQztRQUNSLE9BQU87WUFDSCxNQUFNbUU7UUFDVjtJQUNKO0lBQ0EsT0FBTztRQUNIekUsUUFBUWlIO1FBQ1IsSUFBSXpDLFFBQVE7WUFDUnZCLGtCQUFrQnVCLElBQUksR0FBRztZQUN6QixPQUFPakI7UUFDWDtRQUNBLElBQUlrQixTQUFTO1lBQ1R4QixrQkFBa0J3QixLQUFLLEdBQUc7WUFDMUIsT0FBT0E7UUFDWDtRQUNBLElBQUlWLGdCQUFnQjtZQUNoQmQsa0JBQWtCYyxZQUFZLEdBQUc7WUFDakMsT0FBT0E7UUFDWDtRQUNBLElBQUlDLGFBQWE7WUFDYmYsa0JBQWtCZSxTQUFTLEdBQUc7WUFDOUIsT0FBT0E7UUFDWDtJQUNKO0FBQ0o7QUFDQSxNQUFNbEYsWUFBWUQsZ0RBQU1BLENBQUMySixjQUFjLENBQUN6SixtREFBV0EsRUFBRSxnQkFBZ0I7SUFDakV5QixPQUFPeEIsdURBQWFBO0FBQ3hCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0NBY0MsR0FBRyxNQUFNeUosU0FBU3hKLHNEQUFRQSxDQUFDOEI7QUFFNUIsU0FBUztBQUVtRCIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpZGVvLXN0cmVhbWluZy8uL25vZGVfbW9kdWxlcy9zd3IvY29yZS9kaXN0L2luZGV4Lm1qcz9mNDhiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdEV4cG9ydHMsIHsgdXNlUmVmLCB1c2VNZW1vLCB1c2VDYWxsYmFjaywgdXNlRGVidWdWYWx1ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVN5bmNFeHRlcm5hbFN0b3JlIH0gZnJvbSAndXNlLXN5bmMtZXh0ZXJuYWwtc3RvcmUvc2hpbS9pbmRleC5qcyc7XG5pbXBvcnQgeyBzZXJpYWxpemUsIE9CSkVDVCwgU1dSQ29uZmlnIGFzIFNXUkNvbmZpZyQxLCBkZWZhdWx0Q29uZmlnLCB3aXRoQXJncywgU1dSR2xvYmFsU3RhdGUsIGNyZWF0ZUNhY2hlSGVscGVyLCBpc1VuZGVmaW5lZCwgZ2V0VGltZXN0YW1wLCBVTkRFRklORUQsIGlzRnVuY3Rpb24sIHJldmFsaWRhdGVFdmVudHMsIGludGVybmFsTXV0YXRlLCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0LCBzdWJzY3JpYmVDYWxsYmFjaywgSVNfU0VSVkVSLCByQUYsIElTX1JFQUNUX0xFR0FDWSwgbWVyZ2VPYmplY3RzIH0gZnJvbSAnc3dyL19pbnRlcm5hbCc7XG5leHBvcnQgeyBtdXRhdGUsIHByZWxvYWQsIHVzZVNXUkNvbmZpZyB9IGZyb20gJ3N3ci9faW50ZXJuYWwnO1xuXG5jb25zdCB1bnN0YWJsZV9zZXJpYWxpemUgPSAoa2V5KT0+c2VyaWFsaXplKGtleSlbMF07XG5cbi8vLyA8cmVmZXJlbmNlIHR5cGVzPVwicmVhY3QvZXhwZXJpbWVudGFsXCIgLz5cbmNvbnN0IHVzZSA9IFJlYWN0RXhwb3J0cy51c2UgfHwgKChwcm9taXNlKT0+e1xuICAgIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgIHRocm93IHByb21pc2U7XG4gICAgfSBlbHNlIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2UudmFsdWU7XG4gICAgfSBlbHNlIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gJ3JlamVjdGVkJykge1xuICAgICAgICB0aHJvdyBwcm9taXNlLnJlYXNvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwcm9taXNlLnN0YXR1cyA9ICdwZW5kaW5nJztcbiAgICAgICAgcHJvbWlzZS50aGVuKCh2KT0+e1xuICAgICAgICAgICAgcHJvbWlzZS5zdGF0dXMgPSAnZnVsZmlsbGVkJztcbiAgICAgICAgICAgIHByb21pc2UudmFsdWUgPSB2O1xuICAgICAgICB9LCAoZSk9PntcbiAgICAgICAgICAgIHByb21pc2Uuc3RhdHVzID0gJ3JlamVjdGVkJztcbiAgICAgICAgICAgIHByb21pc2UucmVhc29uID0gZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRocm93IHByb21pc2U7XG4gICAgfVxufSk7XG5jb25zdCBXSVRIX0RFRFVQRSA9IHtcbiAgICBkZWR1cGU6IHRydWVcbn07XG5jb25zdCB1c2VTV1JIYW5kbGVyID0gKF9rZXksIGZldGNoZXIsIGNvbmZpZyk9PntcbiAgICBjb25zdCB7IGNhY2hlICwgY29tcGFyZSAsIHN1c3BlbnNlICwgZmFsbGJhY2tEYXRhICwgcmV2YWxpZGF0ZU9uTW91bnQgLCByZXZhbGlkYXRlSWZTdGFsZSAsIHJlZnJlc2hJbnRlcnZhbCAsIHJlZnJlc2hXaGVuSGlkZGVuICwgcmVmcmVzaFdoZW5PZmZsaW5lICwga2VlcFByZXZpb3VzRGF0YSAgfSA9IGNvbmZpZztcbiAgICBjb25zdCBbRVZFTlRfUkVWQUxJREFUT1JTLCBNVVRBVElPTiwgRkVUQ0gsIFBSRUxPQURdID0gU1dSR2xvYmFsU3RhdGUuZ2V0KGNhY2hlKTtcbiAgICAvLyBga2V5YCBpcyB0aGUgaWRlbnRpZmllciBvZiB0aGUgU1dSIGludGVybmFsIHN0YXRlLFxuICAgIC8vIGBmbkFyZ2AgaXMgdGhlIGFyZ3VtZW50L2FyZ3VtZW50cyBwYXJzZWQgZnJvbSB0aGUga2V5LCB3aGljaCB3aWxsIGJlIHBhc3NlZFxuICAgIC8vIHRvIHRoZSBmZXRjaGVyLlxuICAgIC8vIEFsbCBvZiB0aGVtIGFyZSBkZXJpdmVkIGZyb20gYF9rZXlgLlxuICAgIGNvbnN0IFtrZXksIGZuQXJnXSA9IHNlcmlhbGl6ZShfa2V5KTtcbiAgICAvLyBJZiBpdCdzIHRoZSBpbml0aWFsIHJlbmRlciBvZiB0aGlzIGhvb2suXG4gICAgY29uc3QgaW5pdGlhbE1vdW50ZWRSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICAgIC8vIElmIHRoZSBob29rIGlzIHVubW91bnRlZCBhbHJlYWR5LiBUaGlzIHdpbGwgYmUgdXNlZCB0byBwcmV2ZW50IHNvbWUgZWZmZWN0c1xuICAgIC8vIHRvIGJlIGNhbGxlZCBhZnRlciB1bm1vdW50aW5nLlxuICAgIGNvbnN0IHVubW91bnRlZFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgLy8gUmVmcyB0byBrZWVwIHRoZSBrZXkgYW5kIGNvbmZpZy5cbiAgICBjb25zdCBrZXlSZWYgPSB1c2VSZWYoa2V5KTtcbiAgICBjb25zdCBmZXRjaGVyUmVmID0gdXNlUmVmKGZldGNoZXIpO1xuICAgIGNvbnN0IGNvbmZpZ1JlZiA9IHVzZVJlZihjb25maWcpO1xuICAgIGNvbnN0IGdldENvbmZpZyA9ICgpPT5jb25maWdSZWYuY3VycmVudDtcbiAgICBjb25zdCBpc0FjdGl2ZSA9ICgpPT5nZXRDb25maWcoKS5pc1Zpc2libGUoKSAmJiBnZXRDb25maWcoKS5pc09ubGluZSgpO1xuICAgIGNvbnN0IFtnZXRDYWNoZSwgc2V0Q2FjaGUsIHN1YnNjcmliZUNhY2hlLCBnZXRJbml0aWFsQ2FjaGVdID0gY3JlYXRlQ2FjaGVIZWxwZXIoY2FjaGUsIGtleSk7XG4gICAgY29uc3Qgc3RhdGVEZXBlbmRlbmNpZXMgPSB1c2VSZWYoe30pLmN1cnJlbnQ7XG4gICAgY29uc3QgZmFsbGJhY2sgPSBpc1VuZGVmaW5lZChmYWxsYmFja0RhdGEpID8gY29uZmlnLmZhbGxiYWNrW2tleV0gOiBmYWxsYmFja0RhdGE7XG4gICAgY29uc3QgaXNFcXVhbCA9IChwcmV2LCBjdXJyZW50KT0+e1xuICAgICAgICBmb3IoY29uc3QgXyBpbiBzdGF0ZURlcGVuZGVuY2llcyl7XG4gICAgICAgICAgICBjb25zdCB0ID0gXztcbiAgICAgICAgICAgIGlmICh0ID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbXBhcmUocHJldlt0XSwgY3VycmVudFt0XSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChwcmV2W3RdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tcGFyZShyZXR1cm5lZERhdGEsIGN1cnJlbnRbdF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50W3RdICE9PSBwcmV2W3RdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBjb25zdCBnZXRTbmFwc2hvdCA9IHVzZU1lbW8oKCk9PntcbiAgICAgICAgY29uc3Qgc2hvdWxkU3RhcnRSZXF1ZXN0ID0gKCgpPT57XG4gICAgICAgICAgICBpZiAoIWtleSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFmZXRjaGVyKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAvLyBJZiBgcmV2YWxpZGF0ZU9uTW91bnRgIGlzIHNldCwgd2UgdGFrZSB0aGUgdmFsdWUgZGlyZWN0bHkuXG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHJldmFsaWRhdGVPbk1vdW50KSkgcmV0dXJuIHJldmFsaWRhdGVPbk1vdW50O1xuICAgICAgICAgICAgLy8gSWYgaXQncyBwYXVzZWQsIHdlIHNraXAgcmV2YWxpZGF0aW9uLlxuICAgICAgICAgICAgaWYgKGdldENvbmZpZygpLmlzUGF1c2VkKCkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzdXNwZW5zZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChyZXZhbGlkYXRlSWZTdGFsZSkpIHJldHVybiByZXZhbGlkYXRlSWZTdGFsZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9KSgpO1xuICAgICAgICAvLyBHZXQgdGhlIGNhY2hlIGFuZCBtZXJnZSBpdCB3aXRoIGV4cGVjdGVkIHN0YXRlcy5cbiAgICAgICAgY29uc3QgZ2V0U2VsZWN0ZWRDYWNoZSA9IChzdGF0ZSk9PntcbiAgICAgICAgICAgIC8vIFdlIG9ubHkgc2VsZWN0IHRoZSBuZWVkZWQgZmllbGRzIGZyb20gdGhlIHN0YXRlLlxuICAgICAgICAgICAgY29uc3Qgc25hcHNob3QgPSBtZXJnZU9iamVjdHMoc3RhdGUpO1xuICAgICAgICAgICAgZGVsZXRlIHNuYXBzaG90Ll9rO1xuICAgICAgICAgICAgaWYgKCFzaG91bGRTdGFydFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc25hcHNob3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlzVmFsaWRhdGluZzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBpc0xvYWRpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgLi4uc25hcHNob3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNhY2hlZERhdGEgPSBnZXRDYWNoZSgpO1xuICAgICAgICBjb25zdCBpbml0aWFsRGF0YSA9IGdldEluaXRpYWxDYWNoZSgpO1xuICAgICAgICBjb25zdCBjbGllbnRTbmFwc2hvdCA9IGdldFNlbGVjdGVkQ2FjaGUoY2FjaGVkRGF0YSk7XG4gICAgICAgIGNvbnN0IHNlcnZlclNuYXBzaG90ID0gY2FjaGVkRGF0YSA9PT0gaW5pdGlhbERhdGEgPyBjbGllbnRTbmFwc2hvdCA6IGdldFNlbGVjdGVkQ2FjaGUoaW5pdGlhbERhdGEpO1xuICAgICAgICAvLyBUbyBtYWtlIHN1cmUgdGhhdCB3ZSBhcmUgcmV0dXJuaW5nIHRoZSBzYW1lIG9iamVjdCByZWZlcmVuY2UgdG8gYXZvaWRcbiAgICAgICAgLy8gdW5uZWNlc3NhcnkgcmUtcmVuZGVycywgd2Uga2VlcCB0aGUgcHJldmlvdXMgc25hcHNob3QgYW5kIHVzZSBkZWVwXG4gICAgICAgIC8vIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgd2UgbmVlZCB0byByZXR1cm4gYSBuZXcgb25lLlxuICAgICAgICBsZXQgbWVtb3JpemVkU25hcHNob3QgPSBjbGllbnRTbmFwc2hvdDtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICgpPT57XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3U25hcHNob3QgPSBnZXRTZWxlY3RlZENhY2hlKGdldENhY2hlKCkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBhcmVSZXN1bHQgPSBpc0VxdWFsKG5ld1NuYXBzaG90LCBtZW1vcml6ZWRTbmFwc2hvdCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbXBhcmVSZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWVudGFsbHksIHdlIHNob3VsZCBhbHdheXMgcmV0dXJuIHRoZSBgbWVtb3JpemVkU25hcHNob3RgIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgLy8gYXMgdGhlcmUncyBubyBjaGFuZ2UgYmV0d2VlbiB0aGUgbmV3IGFuZCBvbGQgc25hcHNob3RzLlxuICAgICAgICAgICAgICAgICAgICAvLyBIb3dldmVyLCBzaW5jZSB0aGUgYGlzRXF1YWxgIGZ1bmN0aW9uIG9ubHkgY29tcGFyZXMgc2VsZWN0ZWQgZmllbGRzLFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgdmFsdWVzIG9mIHRoZSB1bnNlbGVjdGVkIGZpZWxkcyBtaWdodCBiZSBjaGFuZ2VkLiBUaGF0J3NcbiAgICAgICAgICAgICAgICAgICAgLy8gc2ltcGx5IGJlY2F1c2Ugd2UgZGlkbid0IHRyYWNrIHRoZW0uXG4gICAgICAgICAgICAgICAgICAgIC8vIFRvIHN1cHBvcnQgdGhlIGNhc2UgaW4gaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9zd3IvcHVsbC8yNTc2LFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGVzZSBmaWVsZHMgaW4gdGhlIGBtZW1vcml6ZWRTbmFwc2hvdGAgdG9vXG4gICAgICAgICAgICAgICAgICAgIC8vIHdpdGggZGlyZWN0IG11dGF0aW9ucyB0byBlbnN1cmUgdGhlIHNuYXBzaG90IGlzIGFsd2F5cyB1cC10by1kYXRlXG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZW4gZm9yIHRoZSB1bnNlbGVjdGVkIGZpZWxkcywgYnV0IG9ubHkgdHJpZ2dlciByZS1yZW5kZXJzIHdoZW5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHNlbGVjdGVkIGZpZWxkcyBhcmUgY2hhbmdlZC5cbiAgICAgICAgICAgICAgICAgICAgbWVtb3JpemVkU25hcHNob3QuZGF0YSA9IG5ld1NuYXBzaG90LmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIG1lbW9yaXplZFNuYXBzaG90LmlzTG9hZGluZyA9IG5ld1NuYXBzaG90LmlzTG9hZGluZztcbiAgICAgICAgICAgICAgICAgICAgbWVtb3JpemVkU25hcHNob3QuaXNWYWxpZGF0aW5nID0gbmV3U25hcHNob3QuaXNWYWxpZGF0aW5nO1xuICAgICAgICAgICAgICAgICAgICBtZW1vcml6ZWRTbmFwc2hvdC5lcnJvciA9IG5ld1NuYXBzaG90LmVycm9yO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbWVtb3JpemVkU25hcHNob3Q7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbWVtb3JpemVkU25hcHNob3QgPSBuZXdTbmFwc2hvdDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ld1NuYXBzaG90O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAoKT0+c2VydmVyU25hcHNob3RcbiAgICAgICAgXTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgfSwgW1xuICAgICAgICBjYWNoZSxcbiAgICAgICAga2V5XG4gICAgXSk7XG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IHN0YXRlIHRoYXQgU1dSIHNob3VsZCByZXR1cm4uXG4gICAgY29uc3QgY2FjaGVkID0gdXNlU3luY0V4dGVybmFsU3RvcmUodXNlQ2FsbGJhY2soKGNhbGxiYWNrKT0+c3Vic2NyaWJlQ2FjaGUoa2V5LCAoY3VycmVudCwgcHJldik9PntcbiAgICAgICAgICAgIGlmICghaXNFcXVhbChwcmV2LCBjdXJyZW50KSkgY2FsbGJhY2soKTtcbiAgICAgICAgfSksIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbXG4gICAgICAgIGNhY2hlLFxuICAgICAgICBrZXlcbiAgICBdKSwgZ2V0U25hcHNob3RbMF0sIGdldFNuYXBzaG90WzFdKTtcbiAgICBjb25zdCBpc0luaXRpYWxNb3VudCA9ICFpbml0aWFsTW91bnRlZFJlZi5jdXJyZW50O1xuICAgIGNvbnN0IGhhc1JldmFsaWRhdG9yID0gRVZFTlRfUkVWQUxJREFUT1JTW2tleV0gJiYgRVZFTlRfUkVWQUxJREFUT1JTW2tleV0ubGVuZ3RoID4gMDtcbiAgICBjb25zdCBjYWNoZWREYXRhID0gY2FjaGVkLmRhdGE7XG4gICAgY29uc3QgZGF0YSA9IGlzVW5kZWZpbmVkKGNhY2hlZERhdGEpID8gZmFsbGJhY2sgOiBjYWNoZWREYXRhO1xuICAgIGNvbnN0IGVycm9yID0gY2FjaGVkLmVycm9yO1xuICAgIC8vIFVzZSBhIHJlZiB0byBzdG9yZSBwcmV2aW91c2x5IHJldHVybmVkIGRhdGEuIFVzZSB0aGUgaW5pdGlhbCBkYXRhIGFzIGl0cyBpbml0aWFsIHZhbHVlLlxuICAgIGNvbnN0IGxhZ2d5RGF0YVJlZiA9IHVzZVJlZihkYXRhKTtcbiAgICBjb25zdCByZXR1cm5lZERhdGEgPSBrZWVwUHJldmlvdXNEYXRhID8gaXNVbmRlZmluZWQoY2FjaGVkRGF0YSkgPyBsYWdneURhdGFSZWYuY3VycmVudCA6IGNhY2hlZERhdGEgOiBkYXRhO1xuICAgIC8vIC0gU3VzcGVuc2UgbW9kZSBhbmQgdGhlcmUncyBzdGFsZSBkYXRhIGZvciB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgLy8gLSBOb3Qgc3VzcGVuc2UgbW9kZSBhbmQgdGhlcmUgaXMgbm8gZmFsbGJhY2sgZGF0YSBhbmQgYHJldmFsaWRhdGVJZlN0YWxlYCBpcyBlbmFibGVkLlxuICAgIC8vIC0gYHJldmFsaWRhdGVJZlN0YWxlYCBpcyBlbmFibGVkIGJ1dCBgZGF0YWAgaXMgbm90IGRlZmluZWQuXG4gICAgY29uc3Qgc2hvdWxkRG9Jbml0aWFsUmV2YWxpZGF0aW9uID0gKCgpPT57XG4gICAgICAgIC8vIGlmIGEga2V5IGFscmVhZHkgaGFzIHJldmFsaWRhdG9ycyBhbmQgYWxzbyBoYXMgZXJyb3IsIHdlIHNob3VsZCBub3QgdHJpZ2dlciByZXZhbGlkYXRpb25cbiAgICAgICAgaWYgKGhhc1JldmFsaWRhdG9yICYmICFpc1VuZGVmaW5lZChlcnJvcikpIHJldHVybiBmYWxzZTtcbiAgICAgICAgLy8gSWYgYHJldmFsaWRhdGVPbk1vdW50YCBpcyBzZXQsIHdlIHRha2UgdGhlIHZhbHVlIGRpcmVjdGx5LlxuICAgICAgICBpZiAoaXNJbml0aWFsTW91bnQgJiYgIWlzVW5kZWZpbmVkKHJldmFsaWRhdGVPbk1vdW50KSkgcmV0dXJuIHJldmFsaWRhdGVPbk1vdW50O1xuICAgICAgICAvLyBJZiBpdCdzIHBhdXNlZCwgd2Ugc2tpcCByZXZhbGlkYXRpb24uXG4gICAgICAgIGlmIChnZXRDb25maWcoKS5pc1BhdXNlZCgpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIFVuZGVyIHN1c3BlbnNlIG1vZGUsIGl0IHdpbGwgYWx3YXlzIGZldGNoIG9uIHJlbmRlciBpZiB0aGVyZSBpcyBub1xuICAgICAgICAvLyBzdGFsZSBkYXRhIHNvIG5vIG5lZWQgdG8gcmV2YWxpZGF0ZSBpbW1lZGlhdGVseSBtb3VudCBpdCBhZ2Fpbi5cbiAgICAgICAgLy8gSWYgZGF0YSBleGlzdHMsIG9ubHkgcmV2YWxpZGF0ZSBpZiBgcmV2YWxpZGF0ZUlmU3RhbGVgIGlzIHRydWUuXG4gICAgICAgIGlmIChzdXNwZW5zZSkgcmV0dXJuIGlzVW5kZWZpbmVkKGRhdGEpID8gZmFsc2UgOiByZXZhbGlkYXRlSWZTdGFsZTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gc3RhbGUgZGF0YSwgd2UgbmVlZCB0byByZXZhbGlkYXRlIHdoZW4gbW91bnQ7XG4gICAgICAgIC8vIElmIGByZXZhbGlkYXRlSWZTdGFsZWAgaXMgc2V0IHRvIHRydWUsIHdlIHdpbGwgYWx3YXlzIHJldmFsaWRhdGUuXG4gICAgICAgIHJldHVybiBpc1VuZGVmaW5lZChkYXRhKSB8fCByZXZhbGlkYXRlSWZTdGFsZTtcbiAgICB9KSgpO1xuICAgIC8vIFJlc29sdmUgdGhlIGRlZmF1bHQgdmFsaWRhdGluZyBzdGF0ZTpcbiAgICAvLyBJZiBpdCdzIGFibGUgdG8gdmFsaWRhdGUsIGFuZCBpdCBzaG91bGQgcmV2YWxpZGF0ZSB3aGVuIG1vdW50LCB0aGlzIHdpbGwgYmUgdHJ1ZS5cbiAgICBjb25zdCBkZWZhdWx0VmFsaWRhdGluZ1N0YXRlID0gISEoa2V5ICYmIGZldGNoZXIgJiYgaXNJbml0aWFsTW91bnQgJiYgc2hvdWxkRG9Jbml0aWFsUmV2YWxpZGF0aW9uKTtcbiAgICBjb25zdCBpc1ZhbGlkYXRpbmcgPSBpc1VuZGVmaW5lZChjYWNoZWQuaXNWYWxpZGF0aW5nKSA/IGRlZmF1bHRWYWxpZGF0aW5nU3RhdGUgOiBjYWNoZWQuaXNWYWxpZGF0aW5nO1xuICAgIGNvbnN0IGlzTG9hZGluZyA9IGlzVW5kZWZpbmVkKGNhY2hlZC5pc0xvYWRpbmcpID8gZGVmYXVsdFZhbGlkYXRpbmdTdGF0ZSA6IGNhY2hlZC5pc0xvYWRpbmc7XG4gICAgLy8gVGhlIHJldmFsaWRhdGlvbiBmdW5jdGlvbiBpcyBhIGNhcmVmdWxseSBjcmFmdGVkIHdyYXBwZXIgb2YgdGhlIG9yaWdpbmFsXG4gICAgLy8gYGZldGNoZXJgLCB0byBjb3JyZWN0bHkgaGFuZGxlIHRoZSBtYW55IGVkZ2UgY2FzZXMuXG4gICAgY29uc3QgcmV2YWxpZGF0ZSA9IHVzZUNhbGxiYWNrKGFzeW5jIChyZXZhbGlkYXRlT3B0cyk9PntcbiAgICAgICAgY29uc3QgY3VycmVudEZldGNoZXIgPSBmZXRjaGVyUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICgha2V5IHx8ICFjdXJyZW50RmV0Y2hlciB8fCB1bm1vdW50ZWRSZWYuY3VycmVudCB8fCBnZXRDb25maWcoKS5pc1BhdXNlZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5ld0RhdGE7XG4gICAgICAgIGxldCBzdGFydEF0O1xuICAgICAgICBsZXQgbG9hZGluZyA9IHRydWU7XG4gICAgICAgIGNvbnN0IG9wdHMgPSByZXZhbGlkYXRlT3B0cyB8fCB7fTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gb25nb2luZyBjb25jdXJyZW50IHJlcXVlc3QsIG9yIGBkZWR1cGVgIGlzIG5vdCBzZXQsIGFcbiAgICAgICAgLy8gbmV3IHJlcXVlc3Qgc2hvdWxkIGJlIGluaXRpYXRlZC5cbiAgICAgICAgY29uc3Qgc2hvdWxkU3RhcnROZXdSZXF1ZXN0ID0gIUZFVENIW2tleV0gfHwgIW9wdHMuZGVkdXBlO1xuICAgICAgICAvKlxuICAgICAgICAgRm9yIFJlYWN0IDE3XG4gICAgICAgICBEbyB1bm1vdW50IGNoZWNrIGZvciBjYWxsczpcbiAgICAgICAgIElmIGtleSBoYXMgY2hhbmdlZCBkdXJpbmcgdGhlIHJldmFsaWRhdGlvbiwgb3IgdGhlIGNvbXBvbmVudCBoYXMgYmVlblxuICAgICAgICAgdW5tb3VudGVkLCBvbGQgZGlzcGF0Y2ggYW5kIG9sZCBldmVudCBjYWxsYmFja3Mgc2hvdWxkIG5vdCB0YWtlIGFueVxuICAgICAgICAgZWZmZWN0XG5cbiAgICAgICAgRm9yIFJlYWN0IDE4XG4gICAgICAgIG9ubHkgY2hlY2sgaWYga2V5IGhhcyBjaGFuZ2VkXG4gICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdHdnL3JlYWN0LTE4L2Rpc2N1c3Npb25zLzgyXG4gICAgICAqLyBjb25zdCBjYWxsYmFja1NhZmVndWFyZCA9ICgpPT57XG4gICAgICAgICAgICBpZiAoSVNfUkVBQ1RfTEVHQUNZKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICF1bm1vdW50ZWRSZWYuY3VycmVudCAmJiBrZXkgPT09IGtleVJlZi5jdXJyZW50ICYmIGluaXRpYWxNb3VudGVkUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ga2V5ID09PSBrZXlSZWYuY3VycmVudDtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gVGhlIGZpbmFsIHN0YXRlIG9iamVjdCB3aGVuIHRoZSByZXF1ZXN0IGZpbmlzaGVzLlxuICAgICAgICBjb25zdCBmaW5hbFN0YXRlID0ge1xuICAgICAgICAgICAgaXNWYWxpZGF0aW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGlzTG9hZGluZzogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZmluaXNoUmVxdWVzdEFuZFVwZGF0ZVN0YXRlID0gKCk9PntcbiAgICAgICAgICAgIHNldENhY2hlKGZpbmFsU3RhdGUpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjbGVhbnVwU3RhdGUgPSAoKT0+e1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBzdGlsbCB0aGUgc2FtZSByZXF1ZXN0IGJlZm9yZSBkZWxldGluZyBpdC5cbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RJbmZvID0gRkVUQ0hba2V5XTtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0SW5mbyAmJiByZXF1ZXN0SW5mb1sxXSA9PT0gc3RhcnRBdCkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBGRVRDSFtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBTdGFydCBmZXRjaGluZy4gQ2hhbmdlIHRoZSBgaXNWYWxpZGF0aW5nYCBzdGF0ZSwgdXBkYXRlIHRoZSBjYWNoZS5cbiAgICAgICAgY29uc3QgaW5pdGlhbFN0YXRlID0ge1xuICAgICAgICAgICAgaXNWYWxpZGF0aW5nOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIC8vIEl0IGlzIGluIHRoZSBgaXNMb2FkaW5nYCBzdGF0ZSwgaWYgYW5kIG9ubHkgaWYgdGhlcmUgaXMgbm8gY2FjaGVkIGRhdGEuXG4gICAgICAgIC8vIFRoaXMgYnlwYXNzZXMgZmFsbGJhY2sgZGF0YSBhbmQgbGFnZ3kgZGF0YS5cbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGdldENhY2hlKCkuZGF0YSkpIHtcbiAgICAgICAgICAgIGluaXRpYWxTdGF0ZS5pc0xvYWRpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgc2V0Q2FjaGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgICAgICAgICAgICAvLyBJZiBubyBjYWNoZSBpcyBiZWluZyByZW5kZXJlZCBjdXJyZW50bHkgKGl0IHNob3dzIGEgYmxhbmsgcGFnZSksXG4gICAgICAgICAgICAgICAgLy8gd2UgdHJpZ2dlciB0aGUgbG9hZGluZyBzbG93IGV2ZW50LlxuICAgICAgICAgICAgICAgIGlmIChjb25maWcubG9hZGluZ1RpbWVvdXQgJiYgaXNVbmRlZmluZWQoZ2V0Q2FjaGUoKS5kYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpPT57XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9hZGluZyAmJiBjYWxsYmFja1NhZmVndWFyZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25Mb2FkaW5nU2xvdyhrZXksIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIGNvbmZpZy5sb2FkaW5nVGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHRoZSByZXF1ZXN0IGFuZCBzYXZlIHRoZSB0aW1lc3RhbXAuXG4gICAgICAgICAgICAgICAgLy8gS2V5IG11c3QgYmUgdHJ1dGh5IGlmIGVudGVyaW5nIGhlcmUuXG4gICAgICAgICAgICAgICAgRkVUQ0hba2V5XSA9IFtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEZldGNoZXIoZm5BcmcpLFxuICAgICAgICAgICAgICAgICAgICBnZXRUaW1lc3RhbXAoKVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBbbmV3RGF0YSwgc3RhcnRBdF0gPSBGRVRDSFtrZXldO1xuICAgICAgICAgICAgbmV3RGF0YSA9IGF3YWl0IG5ld0RhdGE7XG4gICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHJlcXVlc3QgaXNuJ3QgaW50ZXJydXB0ZWQsIGNsZWFuIGl0IHVwIGFmdGVyIHRoZVxuICAgICAgICAgICAgICAgIC8vIGRlZHVwbGljYXRpb24gaW50ZXJ2YWwuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChjbGVhbnVwU3RhdGUsIGNvbmZpZy5kZWR1cGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3JlIG90aGVyIG9uZ29pbmcgcmVxdWVzdChzKSwgc3RhcnRlZCBhZnRlciB0aGUgY3VycmVudCBvbmUsXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGlnbm9yZSB0aGUgY3VycmVudCBvbmUgdG8gYXZvaWQgcG9zc2libGUgcmFjZSBjb25kaXRpb25zOlxuICAgICAgICAgICAgLy8gICByZXExLS0tLS0tLS0tLS0tLS0tLS0tPnJlczEgICAgICAgIChjdXJyZW50IG9uZSlcbiAgICAgICAgICAgIC8vICAgICAgICByZXEyLS0tLS0tLS0tLS0tLS0tLT5yZXMyXG4gICAgICAgICAgICAvLyB0aGUgcmVxdWVzdCB0aGF0IGZpcmVkIGxhdGVyIHdpbGwgYWx3YXlzIGJlIGtlcHQuXG4gICAgICAgICAgICAvLyBUaGUgdGltZXN0YW1wIG1heWJlIGJlIGB1bmRlZmluZWRgIG9yIGEgbnVtYmVyXG4gICAgICAgICAgICBpZiAoIUZFVENIW2tleV0gfHwgRkVUQ0hba2V5XVsxXSAhPT0gc3RhcnRBdCkge1xuICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrU2FmZWd1YXJkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldENvbmZpZygpLm9uRGlzY2FyZGVkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2xlYXIgZXJyb3IuXG4gICAgICAgICAgICBmaW5hbFN0YXRlLmVycm9yID0gVU5ERUZJTkVEO1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUncmUgb3RoZXIgbXV0YXRpb25zKHMpLCB0aGF0IG92ZXJsYXBwZWQgd2l0aCB0aGUgY3VycmVudCByZXZhbGlkYXRpb246XG4gICAgICAgICAgICAvLyBjYXNlIDE6XG4gICAgICAgICAgICAvLyAgIHJlcS0tLS0tLS0tLS0tLS0tLS0tLT5yZXNcbiAgICAgICAgICAgIC8vICAgICAgIG11dGF0ZS0tLS0tLT5lbmRcbiAgICAgICAgICAgIC8vIGNhc2UgMjpcbiAgICAgICAgICAgIC8vICAgICAgICAgcmVxLS0tLS0tLS0tLS0tPnJlc1xuICAgICAgICAgICAgLy8gICBtdXRhdGUtLS0tLS0+ZW5kXG4gICAgICAgICAgICAvLyBjYXNlIDM6XG4gICAgICAgICAgICAvLyAgIHJlcS0tLS0tLS0tLS0tLS0tLS0tLT5yZXNcbiAgICAgICAgICAgIC8vICAgICAgIG11dGF0ZS0tLS0tLS0uLi4tLS0tLS0tLS0tPlxuICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byBpZ25vcmUgdGhlIHJldmFsaWRhdGlvbiByZXN1bHQgKHJlcykgYmVjYXVzZSBpdCdzIG5vIGxvbmdlciBmcmVzaC5cbiAgICAgICAgICAgIC8vIG1lYW53aGlsZSwgYSBuZXcgcmV2YWxpZGF0aW9uIHNob3VsZCBiZSB0cmlnZ2VyZWQgd2hlbiB0aGUgbXV0YXRpb24gZW5kcy5cbiAgICAgICAgICAgIGNvbnN0IG11dGF0aW9uSW5mbyA9IE1VVEFUSU9OW2tleV07XG4gICAgICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKG11dGF0aW9uSW5mbykgJiYgLy8gY2FzZSAxXG4gICAgICAgICAgICAoc3RhcnRBdCA8PSBtdXRhdGlvbkluZm9bMF0gfHwgLy8gY2FzZSAyXG4gICAgICAgICAgICBzdGFydEF0IDw9IG11dGF0aW9uSW5mb1sxXSB8fCAvLyBjYXNlIDNcbiAgICAgICAgICAgIG11dGF0aW9uSW5mb1sxXSA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICBmaW5pc2hSZXF1ZXN0QW5kVXBkYXRlU3RhdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFja1NhZmVndWFyZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRDb25maWcoKS5vbkRpc2NhcmRlZChrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERlZXAgY29tcGFyZSB3aXRoIHRoZSBsYXRlc3Qgc3RhdGUgdG8gYXZvaWQgZXh0cmEgcmUtcmVuZGVycy5cbiAgICAgICAgICAgIC8vIEZvciBsb2NhbCBzdGF0ZSwgY29tcGFyZSBhbmQgYXNzaWduLlxuICAgICAgICAgICAgY29uc3QgY2FjaGVEYXRhID0gZ2V0Q2FjaGUoKS5kYXRhO1xuICAgICAgICAgICAgLy8gU2luY2UgdGhlIGNvbXBhcmUgZm4gY291bGQgYmUgY3VzdG9tIGZuXG4gICAgICAgICAgICAvLyBjYWNoZURhdGEgbWlnaHQgYmUgZGlmZmVyZW50IGZyb20gbmV3RGF0YSBldmVuIHdoZW4gY29tcGFyZSBmbiByZXR1cm5zIFRydWVcbiAgICAgICAgICAgIGZpbmFsU3RhdGUuZGF0YSA9IGNvbXBhcmUoY2FjaGVEYXRhLCBuZXdEYXRhKSA/IGNhY2hlRGF0YSA6IG5ld0RhdGE7XG4gICAgICAgICAgICAvLyBUcmlnZ2VyIHRoZSBzdWNjZXNzZnVsIGNhbGxiYWNrIGlmIGl0J3MgdGhlIG9yaWdpbmFsIHJlcXVlc3QuXG4gICAgICAgICAgICBpZiAoc2hvdWxkU3RhcnROZXdSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrU2FmZWd1YXJkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0Q29uZmlnKCkub25TdWNjZXNzKG5ld0RhdGEsIGtleSwgY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY2xlYW51cFN0YXRlKCk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50Q29uZmlnID0gZ2V0Q29uZmlnKCk7XG4gICAgICAgICAgICBjb25zdCB7IHNob3VsZFJldHJ5T25FcnJvciAgfSA9IGN1cnJlbnRDb25maWc7XG4gICAgICAgICAgICAvLyBOb3QgcGF1c2VkLCB3ZSBjb250aW51ZSBoYW5kbGluZyB0aGUgZXJyb3IuIE90aGVyd2lzZSwgZGlzY2FyZCBpdC5cbiAgICAgICAgICAgIGlmICghY3VycmVudENvbmZpZy5pc1BhdXNlZCgpKSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IGEgbmV3IGVycm9yLCBkb24ndCB1c2UgZGVlcCBjb21wYXJpc29uIGZvciBlcnJvcnMuXG4gICAgICAgICAgICAgICAgZmluYWxTdGF0ZS5lcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICAvLyBFcnJvciBldmVudCBhbmQgcmV0cnkgbG9naWMuIE9ubHkgZm9yIHRoZSBhY3R1YWwgcmVxdWVzdCwgbm90XG4gICAgICAgICAgICAgICAgLy8gZGVkdXBlZCBvbmVzLlxuICAgICAgICAgICAgICAgIGlmIChzaG91bGRTdGFydE5ld1JlcXVlc3QgJiYgY2FsbGJhY2tTYWZlZ3VhcmQoKSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29uZmlnLm9uRXJyb3IoZXJyLCBrZXksIGN1cnJlbnRDb25maWcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkUmV0cnlPbkVycm9yID09PSB0cnVlIHx8IGlzRnVuY3Rpb24oc2hvdWxkUmV0cnlPbkVycm9yKSAmJiBzaG91bGRSZXRyeU9uRXJyb3IoZXJyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBpdCdzIGluYWN0aXZlLCBzdG9wLiBJdCB3aWxsIGF1dG8tcmV2YWxpZGF0ZSB3aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVmb2N1c2luZyBvciByZWNvbm5lY3RpbmcuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiByZXRyeWluZywgZGVkdXBsaWNhdGlvbiBpcyBhbHdheXMgZW5hYmxlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q29uZmlnLm9uRXJyb3JSZXRyeShlcnIsIGtleSwgY3VycmVudENvbmZpZywgKF9vcHRzKT0+e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXZhbGlkYXRvcnMgPSBFVkVOVF9SRVZBTElEQVRPUlNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldmFsaWRhdG9ycyAmJiByZXZhbGlkYXRvcnNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldmFsaWRhdG9yc1swXShyZXZhbGlkYXRlRXZlbnRzLkVSUk9SX1JFVkFMSURBVEVfRVZFTlQsIF9vcHRzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0cnlDb3VudDogKG9wdHMucmV0cnlDb3VudCB8fCAwKSArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZHVwZTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE1hcmsgbG9hZGluZyBhcyBzdG9wcGVkLlxuICAgICAgICBsb2FkaW5nID0gZmFsc2U7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgY3VycmVudCBob29rJ3Mgc3RhdGUuXG4gICAgICAgIGZpbmlzaFJlcXVlc3RBbmRVcGRhdGVTdGF0ZSgpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LCAvLyBgc2V0U3RhdGVgIGlzIGltbXV0YWJsZSwgYW5kIGBldmVudHNDYWxsYmFja2AsIGBmbkFyZ2AsIGFuZFxuICAgIC8vIGBrZXlWYWxpZGF0aW5nYCBhcmUgZGVwZW5kaW5nIG9uIGBrZXlgLCBzbyB3ZSBjYW4gZXhjbHVkZSB0aGVtIGZyb21cbiAgICAvLyB0aGUgZGVwcyBhcnJheS5cbiAgICAvL1xuICAgIC8vIEZJWE1FOlxuICAgIC8vIGBmbmAgYW5kIGBjb25maWdgIG1pZ2h0IGJlIGNoYW5nZWQgZHVyaW5nIHRoZSBsaWZlY3ljbGUsXG4gICAgLy8gYnV0IHRoZXkgbWlnaHQgYmUgY2hhbmdlZCBldmVyeSByZW5kZXIgbGlrZSB0aGlzLlxuICAgIC8vIGB1c2VTV1IoJ2tleScsICgpID0+IGZldGNoKCcvYXBpLycpLCB7IHN1c3BlbnNlOiB0cnVlIH0pYFxuICAgIC8vIFNvIHdlIG9taXQgdGhlIHZhbHVlcyBmcm9tIHRoZSBkZXBzIGFycmF5XG4gICAgLy8gZXZlbiB0aG91Z2ggaXQgbWlnaHQgY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvcnMuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtcbiAgICAgICAga2V5LFxuICAgICAgICBjYWNoZVxuICAgIF0pO1xuICAgIC8vIFNpbWlsYXIgdG8gdGhlIGdsb2JhbCBtdXRhdGUgYnV0IGJvdW5kIHRvIHRoZSBjdXJyZW50IGNhY2hlIGFuZCBrZXkuXG4gICAgLy8gYGNhY2hlYCBpc24ndCBhbGxvd2VkIHRvIGNoYW5nZSBkdXJpbmcgdGhlIGxpZmVjeWNsZS5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgY29uc3QgYm91bmRNdXRhdGUgPSB1c2VDYWxsYmFjaygvLyBVc2UgY2FsbGJhY2sgdG8gbWFrZSBzdXJlIGBrZXlSZWYuY3VycmVudGAgcmV0dXJucyBsYXRlc3QgcmVzdWx0IGV2ZXJ5IHRpbWVcbiAgICAoLi4uYXJncyk9PntcbiAgICAgICAgcmV0dXJuIGludGVybmFsTXV0YXRlKGNhY2hlLCBrZXlSZWYuY3VycmVudCwgLi4uYXJncyk7XG4gICAgfSwgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtdKTtcbiAgICAvLyBUaGUgbG9naWMgZm9yIHVwZGF0aW5nIHJlZnMuXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKT0+e1xuICAgICAgICBmZXRjaGVyUmVmLmN1cnJlbnQgPSBmZXRjaGVyO1xuICAgICAgICBjb25maWdSZWYuY3VycmVudCA9IGNvbmZpZztcbiAgICAgICAgLy8gSGFuZGxlIGxhZ2d5IGRhdGEgdXBkYXRlcy4gSWYgdGhlcmUncyBjYWNoZWQgZGF0YSBvZiB0aGUgY3VycmVudCBrZXksXG4gICAgICAgIC8vIGl0J2xsIGJlIHRoZSBjb3JyZWN0IHJlZmVyZW5jZS5cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChjYWNoZWREYXRhKSkge1xuICAgICAgICAgICAgbGFnZ3lEYXRhUmVmLmN1cnJlbnQgPSBjYWNoZWREYXRhO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gQWZ0ZXIgbW91bnRlZCBvciBrZXkgY2hhbmdlZC5cbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpPT57XG4gICAgICAgIGlmICgha2V5KSByZXR1cm47XG4gICAgICAgIGNvbnN0IHNvZnRSZXZhbGlkYXRlID0gcmV2YWxpZGF0ZS5iaW5kKFVOREVGSU5FRCwgV0lUSF9ERURVUEUpO1xuICAgICAgICAvLyBFeHBvc2UgcmV2YWxpZGF0b3JzIHRvIGdsb2JhbCBldmVudCBsaXN0ZW5lcnMuIFNvIHdlIGNhbiB0cmlnZ2VyXG4gICAgICAgIC8vIHJldmFsaWRhdGlvbiBmcm9tIHRoZSBvdXRzaWRlLlxuICAgICAgICBsZXQgbmV4dEZvY3VzUmV2YWxpZGF0ZWRBdCA9IDA7XG4gICAgICAgIGNvbnN0IG9uUmV2YWxpZGF0ZSA9ICh0eXBlLCBvcHRzID0ge30pPT57XG4gICAgICAgICAgICBpZiAodHlwZSA9PSByZXZhbGlkYXRlRXZlbnRzLkZPQ1VTX0VWRU5UKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0Q29uZmlnKCkucmV2YWxpZGF0ZU9uRm9jdXMgJiYgbm93ID4gbmV4dEZvY3VzUmV2YWxpZGF0ZWRBdCAmJiBpc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRGb2N1c1JldmFsaWRhdGVkQXQgPSBub3cgKyBnZXRDb25maWcoKS5mb2N1c1Rocm90dGxlSW50ZXJ2YWw7XG4gICAgICAgICAgICAgICAgICAgIHNvZnRSZXZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09IHJldmFsaWRhdGVFdmVudHMuUkVDT05ORUNUX0VWRU5UKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdldENvbmZpZygpLnJldmFsaWRhdGVPblJlY29ubmVjdCAmJiBpc0FjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvZnRSZXZhbGlkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09IHJldmFsaWRhdGVFdmVudHMuTVVUQVRFX0VWRU5UKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldmFsaWRhdGUoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PSByZXZhbGlkYXRlRXZlbnRzLkVSUk9SX1JFVkFMSURBVEVfRVZFTlQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV2YWxpZGF0ZShvcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdW5zdWJFdmVudHMgPSBzdWJzY3JpYmVDYWxsYmFjayhrZXksIEVWRU5UX1JFVkFMSURBVE9SUywgb25SZXZhbGlkYXRlKTtcbiAgICAgICAgLy8gTWFyayB0aGUgY29tcG9uZW50IGFzIG1vdW50ZWQgYW5kIHVwZGF0ZSBjb3JyZXNwb25kaW5nIHJlZnMuXG4gICAgICAgIHVubW91bnRlZFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIGtleVJlZi5jdXJyZW50ID0ga2V5O1xuICAgICAgICBpbml0aWFsTW91bnRlZFJlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgLy8gS2VlcCB0aGUgb3JpZ2luYWwga2V5IGluIHRoZSBjYWNoZS5cbiAgICAgICAgc2V0Q2FjaGUoe1xuICAgICAgICAgICAgX2s6IGZuQXJnXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUcmlnZ2VyIGEgcmV2YWxpZGF0aW9uXG4gICAgICAgIGlmIChzaG91bGREb0luaXRpYWxSZXZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChkYXRhKSB8fCBJU19TRVJWRVIpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXZhbGlkYXRlIGltbWVkaWF0ZWx5LlxuICAgICAgICAgICAgICAgIHNvZnRSZXZhbGlkYXRlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIERlbGF5IHRoZSByZXZhbGlkYXRlIGlmIHdlIGhhdmUgZGF0YSB0byByZXR1cm4gc28gd2Ugd29uJ3QgYmxvY2tcbiAgICAgICAgICAgICAgICAvLyByZW5kZXJpbmcuXG4gICAgICAgICAgICAgICAgckFGKHNvZnRSZXZhbGlkYXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKCk9PntcbiAgICAgICAgICAgIC8vIE1hcmsgaXQgYXMgdW5tb3VudGVkLlxuICAgICAgICAgICAgdW5tb3VudGVkUmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgdW5zdWJFdmVudHMoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIGtleVxuICAgIF0pO1xuICAgIC8vIFBvbGxpbmdcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpPT57XG4gICAgICAgIGxldCB0aW1lcjtcbiAgICAgICAgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICAgIC8vIFVzZSB0aGUgcGFzc2VkIGludGVydmFsXG4gICAgICAgICAgICAvLyAuLi5vciBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIHVwZGF0ZWQgZGF0YSB0byBnZXQgdGhlIGludGVydmFsXG4gICAgICAgICAgICBjb25zdCBpbnRlcnZhbCA9IGlzRnVuY3Rpb24ocmVmcmVzaEludGVydmFsKSA/IHJlZnJlc2hJbnRlcnZhbChnZXRDYWNoZSgpLmRhdGEpIDogcmVmcmVzaEludGVydmFsO1xuICAgICAgICAgICAgLy8gV2Ugb25seSBzdGFydCB0aGUgbmV4dCBpbnRlcnZhbCBpZiBgcmVmcmVzaEludGVydmFsYCBpcyBub3QgMCwgYW5kOlxuICAgICAgICAgICAgLy8gLSBgZm9yY2VgIGlzIHRydWUsIHdoaWNoIGlzIHRoZSBzdGFydCBvZiBwb2xsaW5nXG4gICAgICAgICAgICAvLyAtIG9yIGB0aW1lcmAgaXMgbm90IDAsIHdoaWNoIG1lYW5zIHRoZSBlZmZlY3Qgd2Fzbid0IGNhbmNlbGVkXG4gICAgICAgICAgICBpZiAoaW50ZXJ2YWwgJiYgdGltZXIgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGV4ZWN1dGUsIGludGVydmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBleGVjdXRlKCkge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyBPSyB0byBleGVjdXRlOlxuICAgICAgICAgICAgLy8gT25seSByZXZhbGlkYXRlIHdoZW4gdGhlIHBhZ2UgaXMgdmlzaWJsZSwgb25saW5lLCBhbmQgbm90IGVycm9yZWQuXG4gICAgICAgICAgICBpZiAoIWdldENhY2hlKCkuZXJyb3IgJiYgKHJlZnJlc2hXaGVuSGlkZGVuIHx8IGdldENvbmZpZygpLmlzVmlzaWJsZSgpKSAmJiAocmVmcmVzaFdoZW5PZmZsaW5lIHx8IGdldENvbmZpZygpLmlzT25saW5lKCkpKSB7XG4gICAgICAgICAgICAgICAgcmV2YWxpZGF0ZShXSVRIX0RFRFVQRSkudGhlbihuZXh0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU2NoZWR1bGUgdGhlIG5leHQgaW50ZXJ2YWwgdG8gY2hlY2sgYWdhaW4uXG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5leHQoKTtcbiAgICAgICAgcmV0dXJuICgpPT57XG4gICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgIHRpbWVyID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW1xuICAgICAgICByZWZyZXNoSW50ZXJ2YWwsXG4gICAgICAgIHJlZnJlc2hXaGVuSGlkZGVuLFxuICAgICAgICByZWZyZXNoV2hlbk9mZmxpbmUsXG4gICAgICAgIGtleVxuICAgIF0pO1xuICAgIC8vIERpc3BsYXkgZGVidWcgaW5mbyBpbiBSZWFjdCBEZXZUb29scy5cbiAgICB1c2VEZWJ1Z1ZhbHVlKHJldHVybmVkRGF0YSk7XG4gICAgLy8gSW4gU3VzcGVuc2UgbW9kZSwgd2UgY2FuJ3QgcmV0dXJuIHRoZSBlbXB0eSBgZGF0YWAgc3RhdGUuXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gYGVycm9yYCwgdGhlIGBlcnJvcmAgbmVlZHMgdG8gYmUgdGhyb3duIHRvIHRoZSBlcnJvciBib3VuZGFyeS5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyBgZXJyb3JgLCB0aGUgYHJldmFsaWRhdGlvbmAgcHJvbWlzZSBuZWVkcyB0byBiZSB0aHJvd24gdG9cbiAgICAvLyB0aGUgc3VzcGVuc2UgYm91bmRhcnkuXG4gICAgaWYgKHN1c3BlbnNlICYmIGlzVW5kZWZpbmVkKGRhdGEpICYmIGtleSkge1xuICAgICAgICAvLyBTV1Igc2hvdWxkIHRocm93IHdoZW4gdHJ5aW5nIHRvIHVzZSBTdXNwZW5zZSBvbiB0aGUgc2VydmVyIHdpdGggUmVhY3QgMTgsXG4gICAgICAgIC8vIHdpdGhvdXQgcHJvdmlkaW5nIGFueSBpbml0aWFsIGRhdGEuIFNlZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC9zd3IvaXNzdWVzLzE4MzJcbiAgICAgICAgaWYgKCFJU19SRUFDVF9MRUdBQ1kgJiYgSVNfU0VSVkVSKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhbGxiYWNrIGRhdGEgaXMgcmVxdWlyZWQgd2hlbiB1c2luZyBzdXNwZW5zZSBpbiBTU1IuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWx3YXlzIHVwZGF0ZSBmZXRjaGVyIGFuZCBjb25maWcgcmVmcyBldmVuIHdpdGggdGhlIFN1c3BlbnNlIG1vZGUuXG4gICAgICAgIGZldGNoZXJSZWYuY3VycmVudCA9IGZldGNoZXI7XG4gICAgICAgIGNvbmZpZ1JlZi5jdXJyZW50ID0gY29uZmlnO1xuICAgICAgICB1bm1vdW50ZWRSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICBjb25zdCByZXEgPSBQUkVMT0FEW2tleV07XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQocmVxKSkge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IGJvdW5kTXV0YXRlKHJlcSk7XG4gICAgICAgICAgICB1c2UocHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGVycm9yKSkge1xuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IHJldmFsaWRhdGUoV0lUSF9ERURVUEUpO1xuICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChyZXR1cm5lZERhdGEpKSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZS5zdGF0dXMgPSAnZnVsZmlsbGVkJztcbiAgICAgICAgICAgICAgICBwcm9taXNlLnZhbHVlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVzZShwcm9taXNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG11dGF0ZTogYm91bmRNdXRhdGUsXG4gICAgICAgIGdldCBkYXRhICgpIHtcbiAgICAgICAgICAgIHN0YXRlRGVwZW5kZW5jaWVzLmRhdGEgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHJldHVybmVkRGF0YTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGVycm9yICgpIHtcbiAgICAgICAgICAgIHN0YXRlRGVwZW5kZW5jaWVzLmVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGlzVmFsaWRhdGluZyAoKSB7XG4gICAgICAgICAgICBzdGF0ZURlcGVuZGVuY2llcy5pc1ZhbGlkYXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGlzVmFsaWRhdGluZztcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0IGlzTG9hZGluZyAoKSB7XG4gICAgICAgICAgICBzdGF0ZURlcGVuZGVuY2llcy5pc0xvYWRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGlzTG9hZGluZztcbiAgICAgICAgfVxuICAgIH07XG59O1xuY29uc3QgU1dSQ29uZmlnID0gT0JKRUNULmRlZmluZVByb3BlcnR5KFNXUkNvbmZpZyQxLCAnZGVmYXVsdFZhbHVlJywge1xuICAgIHZhbHVlOiBkZWZhdWx0Q29uZmlnXG59KTtcbi8qKlxuICogQSBob29rIHRvIGZldGNoIGRhdGEuXG4gKlxuICogQGxpbmsgaHR0cHM6Ly9zd3IudmVyY2VsLmFwcFxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICogaW1wb3J0IHVzZVNXUiBmcm9tICdzd3InXG4gKiBmdW5jdGlvbiBQcm9maWxlKCkge1xuICogICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSB1c2VTV1IoJy9hcGkvdXNlcicsIGZldGNoZXIpXG4gKiAgIGlmIChlcnJvcikgcmV0dXJuIDxkaXY+ZmFpbGVkIHRvIGxvYWQ8L2Rpdj5cbiAqICAgaWYgKCFkYXRhKSByZXR1cm4gPGRpdj5sb2FkaW5nLi4uPC9kaXY+XG4gKiAgIHJldHVybiA8ZGl2PmhlbGxvIHtkYXRhLm5hbWV9ITwvZGl2PlxuICogfVxuICogYGBgXG4gKi8gY29uc3QgdXNlU1dSID0gd2l0aEFyZ3ModXNlU1dSSGFuZGxlcik7XG5cbi8vIHVzZVNXUlxuXG5leHBvcnQgeyBTV1JDb25maWcsIHVzZVNXUiBhcyBkZWZhdWx0LCB1bnN0YWJsZV9zZXJpYWxpemUgfTtcbiJdLCJuYW1lcyI6WyJSZWFjdEV4cG9ydHMiLCJ1c2VSZWYiLCJ1c2VNZW1vIiwidXNlQ2FsbGJhY2siLCJ1c2VEZWJ1Z1ZhbHVlIiwidXNlU3luY0V4dGVybmFsU3RvcmUiLCJzZXJpYWxpemUiLCJPQkpFQ1QiLCJTV1JDb25maWciLCJTV1JDb25maWckMSIsImRlZmF1bHRDb25maWciLCJ3aXRoQXJncyIsIlNXUkdsb2JhbFN0YXRlIiwiY3JlYXRlQ2FjaGVIZWxwZXIiLCJpc1VuZGVmaW5lZCIsImdldFRpbWVzdGFtcCIsIlVOREVGSU5FRCIsImlzRnVuY3Rpb24iLCJyZXZhbGlkYXRlRXZlbnRzIiwiaW50ZXJuYWxNdXRhdGUiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0Iiwic3Vic2NyaWJlQ2FsbGJhY2siLCJJU19TRVJWRVIiLCJyQUYiLCJJU19SRUFDVF9MRUdBQ1kiLCJtZXJnZU9iamVjdHMiLCJtdXRhdGUiLCJwcmVsb2FkIiwidXNlU1dSQ29uZmlnIiwidW5zdGFibGVfc2VyaWFsaXplIiwia2V5IiwidXNlIiwicHJvbWlzZSIsInN0YXR1cyIsInZhbHVlIiwicmVhc29uIiwidGhlbiIsInYiLCJlIiwiV0lUSF9ERURVUEUiLCJkZWR1cGUiLCJ1c2VTV1JIYW5kbGVyIiwiX2tleSIsImZldGNoZXIiLCJjb25maWciLCJjYWNoZSIsImNvbXBhcmUiLCJzdXNwZW5zZSIsImZhbGxiYWNrRGF0YSIsInJldmFsaWRhdGVPbk1vdW50IiwicmV2YWxpZGF0ZUlmU3RhbGUiLCJyZWZyZXNoSW50ZXJ2YWwiLCJyZWZyZXNoV2hlbkhpZGRlbiIsInJlZnJlc2hXaGVuT2ZmbGluZSIsImtlZXBQcmV2aW91c0RhdGEiLCJFVkVOVF9SRVZBTElEQVRPUlMiLCJNVVRBVElPTiIsIkZFVENIIiwiUFJFTE9BRCIsImdldCIsImZuQXJnIiwiaW5pdGlhbE1vdW50ZWRSZWYiLCJ1bm1vdW50ZWRSZWYiLCJrZXlSZWYiLCJmZXRjaGVyUmVmIiwiY29uZmlnUmVmIiwiZ2V0Q29uZmlnIiwiY3VycmVudCIsImlzQWN0aXZlIiwiaXNWaXNpYmxlIiwiaXNPbmxpbmUiLCJnZXRDYWNoZSIsInNldENhY2hlIiwic3Vic2NyaWJlQ2FjaGUiLCJnZXRJbml0aWFsQ2FjaGUiLCJzdGF0ZURlcGVuZGVuY2llcyIsImZhbGxiYWNrIiwiaXNFcXVhbCIsInByZXYiLCJfIiwidCIsInJldHVybmVkRGF0YSIsImdldFNuYXBzaG90Iiwic2hvdWxkU3RhcnRSZXF1ZXN0IiwiaXNQYXVzZWQiLCJnZXRTZWxlY3RlZENhY2hlIiwic3RhdGUiLCJzbmFwc2hvdCIsIl9rIiwiaXNWYWxpZGF0aW5nIiwiaXNMb2FkaW5nIiwiY2FjaGVkRGF0YSIsImluaXRpYWxEYXRhIiwiY2xpZW50U25hcHNob3QiLCJzZXJ2ZXJTbmFwc2hvdCIsIm1lbW9yaXplZFNuYXBzaG90IiwibmV3U25hcHNob3QiLCJjb21wYXJlUmVzdWx0IiwiZGF0YSIsImVycm9yIiwiY2FjaGVkIiwiY2FsbGJhY2siLCJpc0luaXRpYWxNb3VudCIsImhhc1JldmFsaWRhdG9yIiwibGVuZ3RoIiwibGFnZ3lEYXRhUmVmIiwic2hvdWxkRG9Jbml0aWFsUmV2YWxpZGF0aW9uIiwiZGVmYXVsdFZhbGlkYXRpbmdTdGF0ZSIsInJldmFsaWRhdGUiLCJyZXZhbGlkYXRlT3B0cyIsImN1cnJlbnRGZXRjaGVyIiwibmV3RGF0YSIsInN0YXJ0QXQiLCJsb2FkaW5nIiwib3B0cyIsInNob3VsZFN0YXJ0TmV3UmVxdWVzdCIsImNhbGxiYWNrU2FmZWd1YXJkIiwiZmluYWxTdGF0ZSIsImZpbmlzaFJlcXVlc3RBbmRVcGRhdGVTdGF0ZSIsImNsZWFudXBTdGF0ZSIsInJlcXVlc3RJbmZvIiwiaW5pdGlhbFN0YXRlIiwibG9hZGluZ1RpbWVvdXQiLCJzZXRUaW1lb3V0Iiwib25Mb2FkaW5nU2xvdyIsImRlZHVwaW5nSW50ZXJ2YWwiLCJvbkRpc2NhcmRlZCIsIm11dGF0aW9uSW5mbyIsImNhY2hlRGF0YSIsIm9uU3VjY2VzcyIsImVyciIsImN1cnJlbnRDb25maWciLCJzaG91bGRSZXRyeU9uRXJyb3IiLCJvbkVycm9yIiwib25FcnJvclJldHJ5IiwiX29wdHMiLCJyZXZhbGlkYXRvcnMiLCJFUlJPUl9SRVZBTElEQVRFX0VWRU5UIiwicmV0cnlDb3VudCIsImJvdW5kTXV0YXRlIiwiYXJncyIsInNvZnRSZXZhbGlkYXRlIiwiYmluZCIsIm5leHRGb2N1c1JldmFsaWRhdGVkQXQiLCJvblJldmFsaWRhdGUiLCJ0eXBlIiwiRk9DVVNfRVZFTlQiLCJub3ciLCJEYXRlIiwicmV2YWxpZGF0ZU9uRm9jdXMiLCJmb2N1c1Rocm90dGxlSW50ZXJ2YWwiLCJSRUNPTk5FQ1RfRVZFTlQiLCJyZXZhbGlkYXRlT25SZWNvbm5lY3QiLCJNVVRBVEVfRVZFTlQiLCJ1bnN1YkV2ZW50cyIsInRpbWVyIiwibmV4dCIsImludGVydmFsIiwiZXhlY3V0ZSIsImNsZWFyVGltZW91dCIsIkVycm9yIiwicmVxIiwiZGVmaW5lUHJvcGVydHkiLCJ1c2VTV1IiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swr/core/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/swr/infinite/dist/index.mjs":
/*!**************************************************!*\
  !*** ./node_modules/swr/infinite/dist/index.mjs ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ useSWRInfinite),\n/* harmony export */   infinite: () => (/* binding */ infinite),\n/* harmony export */   unstable_serialize: () => (/* binding */ unstable_serialize)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! swr */ \"(ssr)/./node_modules/swr/core/dist/index.mjs\");\n/* harmony import */ var swr_internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! swr/_internal */ \"(ssr)/./node_modules/swr/_internal/dist/index.mjs\");\n/* harmony import */ var use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! use-sync-external-store/shim/index.js */ \"(ssr)/./node_modules/use-sync-external-store/shim/index.js\");\n\n\n\n\nconst INFINITE_PREFIX = \"$inf$\";\nconst getFirstPageKey = (getKey)=>{\n    return (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.serialize)(getKey ? getKey(0, null) : null)[0];\n};\nconst unstable_serialize = (getKey)=>{\n    return INFINITE_PREFIX + getFirstPageKey(getKey);\n};\n// We have to several type castings here because `useSWRInfinite` is a special\n// const INFINITE_PREFIX = '$inf$'\nconst EMPTY_PROMISE = Promise.resolve();\n// export const unstable_serialize = (getKey: SWRInfiniteKeyLoader) => {\n//   return INFINITE_PREFIX + getFirstPageKey(getKey)\n// }\nconst infinite = (useSWRNext)=>(getKey, fn, config)=>{\n        const didMountRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n        const { cache, initialSize = 1, revalidateAll = false, persistSize = false, revalidateFirstPage = true, revalidateOnMount = false, parallel = false } = config;\n        // The serialized key of the first page. This key will be used to store\n        // metadata of this SWR infinite hook.\n        let infiniteKey;\n        try {\n            infiniteKey = getFirstPageKey(getKey);\n            if (infiniteKey) infiniteKey = INFINITE_PREFIX + infiniteKey;\n        } catch (err) {\n        // Not ready yet.\n        }\n        const [get, set, subscribeCache] = (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.createCacheHelper)(cache, infiniteKey);\n        const getSnapshot = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n            const size = (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(get()._l) ? initialSize : get()._l;\n            return size;\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            cache,\n            infiniteKey,\n            initialSize\n        ]);\n        (0,use_sync_external_store_shim_index_js__WEBPACK_IMPORTED_MODULE_3__.useSyncExternalStore)((0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((callback)=>{\n            if (infiniteKey) return subscribeCache(infiniteKey, ()=>{\n                callback();\n            });\n            return ()=>{};\n        }, [\n            cache,\n            infiniteKey\n        ]), getSnapshot, getSnapshot);\n        const resolvePageSize = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(()=>{\n            const cachedPageSize = get()._l;\n            return (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(cachedPageSize) ? initialSize : cachedPageSize;\n        // `cache` isn't allowed to change during the lifecycle\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            infiniteKey,\n            initialSize\n        ]);\n        // keep the last page size to restore it with the persistSize option\n        const lastPageSizeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(resolvePageSize());\n        // When the page key changes, we reset the page size if it's not persisted\n        (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.useIsomorphicLayoutEffect)(()=>{\n            if (!didMountRef.current) {\n                didMountRef.current = true;\n                return;\n            }\n            if (infiniteKey) {\n                // If the key has been changed, we keep the current page size if persistSize is enabled\n                // Otherwise, we reset the page size to cached pageSize\n                set({\n                    _l: persistSize ? lastPageSizeRef.current : resolvePageSize()\n                });\n            }\n        // `initialSize` isn't allowed to change during the lifecycle\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        }, [\n            infiniteKey,\n            cache\n        ]);\n        // Needs to check didMountRef during mounting, not in the fetcher\n        const shouldRevalidateOnMount = revalidateOnMount && !didMountRef.current;\n        // Actual SWR hook to load all pages in one fetcher.\n        const swr = useSWRNext(infiniteKey, async (key)=>{\n            // get the revalidate context\n            const forceRevalidateAll = get()._i;\n            // return an array of page data\n            const data = [];\n            const pageSize = resolvePageSize();\n            const [getCache] = (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.createCacheHelper)(cache, key);\n            const cacheData = getCache().data;\n            const revalidators = [];\n            let previousPageData = null;\n            for(let i = 0; i < pageSize; ++i){\n                const [pageKey, pageArg] = (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.serialize)(getKey(i, parallel ? null : previousPageData));\n                if (!pageKey) {\n                    break;\n                }\n                const [getSWRCache, setSWRCache] = (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.createCacheHelper)(cache, pageKey);\n                // Get the cached page data.\n                let pageData = getSWRCache().data;\n                // should fetch (or revalidate) if:\n                // - `revalidateAll` is enabled\n                // - `mutate()` called\n                // - the cache is missing\n                // - it's the first page and it's not the initial render\n                // - `revalidateOnMount` is enabled and it's on mount\n                // - cache for that page has changed\n                const shouldFetchPage = revalidateAll || forceRevalidateAll || (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(pageData) || revalidateFirstPage && !i && !(0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(cacheData) || shouldRevalidateOnMount || cacheData && !(0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(cacheData[i]) && !config.compare(cacheData[i], pageData);\n                if (fn && shouldFetchPage) {\n                    const revalidate = async ()=>{\n                        pageData = await fn(pageArg);\n                        setSWRCache({\n                            data: pageData,\n                            _k: pageArg\n                        });\n                        data[i] = pageData;\n                    };\n                    if (parallel) {\n                        revalidators.push(revalidate);\n                    } else {\n                        await revalidate();\n                    }\n                } else {\n                    data[i] = pageData;\n                }\n                if (!parallel) {\n                    previousPageData = pageData;\n                }\n            }\n            // flush all revalidateions in parallel\n            if (parallel) {\n                await Promise.all(revalidators.map((r)=>r()));\n            }\n            // once we executed the data fetching based on the context, clear the context\n            set({\n                _i: swr_internal__WEBPACK_IMPORTED_MODULE_2__.UNDEFINED\n            });\n            // return the data\n            return data;\n        }, config);\n        const mutate = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function(data, opts) {\n            // When passing as a boolean, it's explicitly used to disable/enable\n            // revalidation.\n            const options = typeof opts === \"boolean\" ? {\n                revalidate: opts\n            } : opts || {};\n            // Default to true.\n            const shouldRevalidate = options.revalidate !== false;\n            // It is possible that the key is still falsy.\n            if (!infiniteKey) return EMPTY_PROMISE;\n            if (shouldRevalidate) {\n                if (!(0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(data)) {\n                    // We only revalidate the pages that are changed\n                    set({\n                        _i: false\n                    });\n                } else {\n                    // Calling `mutate()`, we revalidate all pages\n                    set({\n                        _i: true\n                    });\n                }\n            }\n            return arguments.length ? swr.mutate(data, {\n                ...options,\n                revalidate: shouldRevalidate\n            }) : swr.mutate();\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            infiniteKey,\n            cache\n        ]);\n        // Extend the SWR API\n        const setSize = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((arg)=>{\n            // It is possible that the key is still falsy.\n            if (!infiniteKey) return EMPTY_PROMISE;\n            const [, changeSize] = (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.createCacheHelper)(cache, infiniteKey);\n            let size;\n            if ((0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isFunction)(arg)) {\n                size = arg(resolvePageSize());\n            } else if (typeof arg == \"number\") {\n                size = arg;\n            }\n            if (typeof size != \"number\") return EMPTY_PROMISE;\n            changeSize({\n                _l: size\n            });\n            lastPageSizeRef.current = size;\n            // Calculate the page data after the size change.\n            const data = [];\n            const [getInfiniteCache] = (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.createCacheHelper)(cache, infiniteKey);\n            let previousPageData = null;\n            for(let i = 0; i < size; ++i){\n                const [pageKey] = (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.serialize)(getKey(i, previousPageData));\n                const [getCache] = (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.createCacheHelper)(cache, pageKey);\n                // Get the cached page data.\n                const pageData = pageKey ? getCache().data : swr_internal__WEBPACK_IMPORTED_MODULE_2__.UNDEFINED;\n                // Call `mutate` with infinte cache data if we can't get it from the page cache.\n                if ((0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(pageData)) {\n                    return mutate(getInfiniteCache().data);\n                }\n                data.push(pageData);\n                previousPageData = pageData;\n            }\n            return mutate(data);\n        }, // eslint-disable-next-line react-hooks/exhaustive-deps\n        [\n            infiniteKey,\n            cache,\n            mutate,\n            resolvePageSize\n        ]);\n        // Use getter functions to avoid unnecessary re-renders caused by triggering\n        // all the getters of the returned swr object.\n        return {\n            size: resolvePageSize(),\n            setSize,\n            mutate,\n            get data () {\n                return swr.data;\n            },\n            get error () {\n                return swr.error;\n            },\n            get isValidating () {\n                return swr.isValidating;\n            },\n            get isLoading () {\n                return swr.isLoading;\n            }\n        };\n    };\nconst useSWRInfinite = (0,swr_internal__WEBPACK_IMPORTED_MODULE_2__.withMiddleware)(swr__WEBPACK_IMPORTED_MODULE_1__[\"default\"], infinite);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc3dyL2luZmluaXRlL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTRDO0FBQ25CO0FBQ21IO0FBQy9EO0FBRTdFLE1BQU1XLGtCQUFrQjtBQUN4QixNQUFNQyxrQkFBa0IsQ0FBQ0M7SUFDckIsT0FBT1YsdURBQVNBLENBQUNVLFNBQVNBLE9BQU8sR0FBRyxRQUFRLEtBQUssQ0FBQyxFQUFFO0FBQ3hEO0FBQ0EsTUFBTUMscUJBQXFCLENBQUNEO0lBQ3hCLE9BQU9GLGtCQUFrQkMsZ0JBQWdCQztBQUM3QztBQUVBLDhFQUE4RTtBQUM5RSxrQ0FBa0M7QUFDbEMsTUFBTUUsZ0JBQWdCQyxRQUFRQyxPQUFPO0FBQ3JDLHdFQUF3RTtBQUN4RSxxREFBcUQ7QUFDckQsSUFBSTtBQUNKLE1BQU1DLFdBQVcsQ0FBQ0MsYUFBYSxDQUFDTixRQUFRTyxJQUFJQztRQUNwQyxNQUFNQyxjQUFjdEIsNkNBQU1BLENBQUM7UUFDM0IsTUFBTSxFQUFFdUIsS0FBSyxFQUFHQyxjQUFhLENBQUMsRUFBR0MsZ0JBQWUsS0FBSyxFQUFHQyxjQUFhLEtBQUssRUFBR0Msc0JBQXFCLElBQUksRUFBR0Msb0JBQW1CLEtBQUssRUFBR0MsV0FBVSxLQUFLLEVBQUcsR0FBR1I7UUFDekosdUVBQXVFO1FBQ3ZFLHNDQUFzQztRQUN0QyxJQUFJUztRQUNKLElBQUk7WUFDQUEsY0FBY2xCLGdCQUFnQkM7WUFDOUIsSUFBSWlCLGFBQWFBLGNBQWNuQixrQkFBa0JtQjtRQUNyRCxFQUFFLE9BQU9DLEtBQUs7UUFDZCxpQkFBaUI7UUFDakI7UUFDQSxNQUFNLENBQUNDLEtBQUtDLEtBQUtDLGVBQWUsR0FBRzdCLCtEQUFpQkEsQ0FBQ2tCLE9BQU9PO1FBQzVELE1BQU1LLGNBQWNsQyxrREFBV0EsQ0FBQztZQUM1QixNQUFNbUMsT0FBTzlCLHlEQUFXQSxDQUFDMEIsTUFBTUssRUFBRSxJQUFJYixjQUFjUSxNQUFNSyxFQUFFO1lBQzNELE9BQU9EO1FBQ1gsdURBQXVEO1FBQ3ZELEdBQUc7WUFDQ2I7WUFDQU87WUFDQU47U0FDSDtRQUNEZCwyRkFBb0JBLENBQUNULGtEQUFXQSxDQUFDLENBQUNxQztZQUM5QixJQUFJUixhQUFhLE9BQU9JLGVBQWVKLGFBQWE7Z0JBQ2hEUTtZQUNKO1lBQ0EsT0FBTyxLQUFLO1FBQ2hCLEdBQ0E7WUFDSWY7WUFDQU87U0FDSCxHQUFHSyxhQUFhQTtRQUNqQixNQUFNSSxrQkFBa0J0QyxrREFBV0EsQ0FBQztZQUNoQyxNQUFNdUMsaUJBQWlCUixNQUFNSyxFQUFFO1lBQy9CLE9BQU8vQix5REFBV0EsQ0FBQ2tDLGtCQUFrQmhCLGNBQWNnQjtRQUN2RCx1REFBdUQ7UUFDdkQsdURBQXVEO1FBQ3ZELEdBQUc7WUFDQ1Y7WUFDQU47U0FDSDtRQUNELG9FQUFvRTtRQUNwRSxNQUFNaUIsa0JBQWtCekMsNkNBQU1BLENBQUN1QztRQUMvQiwwRUFBMEU7UUFDMUVoQyx1RUFBeUJBLENBQUM7WUFDdEIsSUFBSSxDQUFDZSxZQUFZb0IsT0FBTyxFQUFFO2dCQUN0QnBCLFlBQVlvQixPQUFPLEdBQUc7Z0JBQ3RCO1lBQ0o7WUFDQSxJQUFJWixhQUFhO2dCQUNiLHVGQUF1RjtnQkFDdkYsdURBQXVEO2dCQUN2REcsSUFBSTtvQkFDQUksSUFBSVgsY0FBY2UsZ0JBQWdCQyxPQUFPLEdBQUdIO2dCQUNoRDtZQUNKO1FBQ0osNkRBQTZEO1FBQzdELHVEQUF1RDtRQUN2RCxHQUFHO1lBQ0NUO1lBQ0FQO1NBQ0g7UUFDRCxpRUFBaUU7UUFDakUsTUFBTW9CLDBCQUEwQmYscUJBQXFCLENBQUNOLFlBQVlvQixPQUFPO1FBQ3pFLG9EQUFvRDtRQUNwRCxNQUFNRSxNQUFNekIsV0FBV1csYUFBYSxPQUFPZTtZQUN2Qyw2QkFBNkI7WUFDN0IsTUFBTUMscUJBQXFCZCxNQUFNZSxFQUFFO1lBQ25DLCtCQUErQjtZQUMvQixNQUFNQyxPQUFPLEVBQUU7WUFDZixNQUFNQyxXQUFXVjtZQUNqQixNQUFNLENBQUNXLFNBQVMsR0FBRzdDLCtEQUFpQkEsQ0FBQ2tCLE9BQU9zQjtZQUM1QyxNQUFNTSxZQUFZRCxXQUFXRixJQUFJO1lBQ2pDLE1BQU1JLGVBQWUsRUFBRTtZQUN2QixJQUFJQyxtQkFBbUI7WUFDdkIsSUFBSSxJQUFJQyxJQUFJLEdBQUdBLElBQUlMLFVBQVUsRUFBRUssRUFBRTtnQkFDN0IsTUFBTSxDQUFDQyxTQUFTQyxRQUFRLEdBQUdyRCx1REFBU0EsQ0FBQ1UsT0FBT3lDLEdBQUd6QixXQUFXLE9BQU93QjtnQkFDakUsSUFBSSxDQUFDRSxTQUFTO29CQUNWO2dCQUNKO2dCQUNBLE1BQU0sQ0FBQ0UsYUFBYUMsWUFBWSxHQUFHckQsK0RBQWlCQSxDQUFDa0IsT0FBT2dDO2dCQUM1RCw0QkFBNEI7Z0JBQzVCLElBQUlJLFdBQVdGLGNBQWNULElBQUk7Z0JBQ2pDLG1DQUFtQztnQkFDbkMsK0JBQStCO2dCQUMvQixzQkFBc0I7Z0JBQ3RCLHlCQUF5QjtnQkFDekIsd0RBQXdEO2dCQUN4RCxxREFBcUQ7Z0JBQ3JELG9DQUFvQztnQkFDcEMsTUFBTVksa0JBQWtCbkMsaUJBQWlCcUIsc0JBQXNCeEMseURBQVdBLENBQUNxRCxhQUFhaEMsdUJBQXVCLENBQUMyQixLQUFLLENBQUNoRCx5REFBV0EsQ0FBQzZDLGNBQWNSLDJCQUEyQlEsYUFBYSxDQUFDN0MseURBQVdBLENBQUM2QyxTQUFTLENBQUNHLEVBQUUsS0FBSyxDQUFDakMsT0FBT3dDLE9BQU8sQ0FBQ1YsU0FBUyxDQUFDRyxFQUFFLEVBQUVLO2dCQUNwUCxJQUFJdkMsTUFBTXdDLGlCQUFpQjtvQkFDdkIsTUFBTUUsYUFBYTt3QkFDZkgsV0FBVyxNQUFNdkMsR0FBR29DO3dCQUNwQkUsWUFBWTs0QkFDUlYsTUFBTVc7NEJBQ05JLElBQUlQO3dCQUNSO3dCQUNBUixJQUFJLENBQUNNLEVBQUUsR0FBR0s7b0JBQ2Q7b0JBQ0EsSUFBSTlCLFVBQVU7d0JBQ1Z1QixhQUFhWSxJQUFJLENBQUNGO29CQUN0QixPQUFPO3dCQUNILE1BQU1BO29CQUNWO2dCQUNKLE9BQU87b0JBQ0hkLElBQUksQ0FBQ00sRUFBRSxHQUFHSztnQkFDZDtnQkFDQSxJQUFJLENBQUM5QixVQUFVO29CQUNYd0IsbUJBQW1CTTtnQkFDdkI7WUFDSjtZQUNBLHVDQUF1QztZQUN2QyxJQUFJOUIsVUFBVTtnQkFDVixNQUFNYixRQUFRaUQsR0FBRyxDQUFDYixhQUFhYyxHQUFHLENBQUMsQ0FBQ0MsSUFBSUE7WUFDNUM7WUFDQSw2RUFBNkU7WUFDN0VsQyxJQUFJO2dCQUNBYyxJQUFJdkMsbURBQVNBO1lBQ2pCO1lBQ0Esa0JBQWtCO1lBQ2xCLE9BQU93QztRQUNYLEdBQUczQjtRQUNILE1BQU0rQyxTQUFTbkUsa0RBQVdBLENBQzFCLFNBQVMrQyxJQUFJLEVBQUVxQixJQUFJO1lBQ2Ysb0VBQW9FO1lBQ3BFLGdCQUFnQjtZQUNoQixNQUFNQyxVQUFVLE9BQU9ELFNBQVMsWUFBWTtnQkFDeENQLFlBQVlPO1lBQ2hCLElBQUlBLFFBQVEsQ0FBQztZQUNiLG1CQUFtQjtZQUNuQixNQUFNRSxtQkFBbUJELFFBQVFSLFVBQVUsS0FBSztZQUNoRCw4Q0FBOEM7WUFDOUMsSUFBSSxDQUFDaEMsYUFBYSxPQUFPZjtZQUN6QixJQUFJd0Qsa0JBQWtCO2dCQUNsQixJQUFJLENBQUNqRSx5REFBV0EsQ0FBQzBDLE9BQU87b0JBQ3BCLGdEQUFnRDtvQkFDaERmLElBQUk7d0JBQ0FjLElBQUk7b0JBQ1I7Z0JBQ0osT0FBTztvQkFDSCw4Q0FBOEM7b0JBQzlDZCxJQUFJO3dCQUNBYyxJQUFJO29CQUNSO2dCQUNKO1lBQ0o7WUFDQSxPQUFPeUIsVUFBVUMsTUFBTSxHQUFHN0IsSUFBSXdCLE1BQU0sQ0FBQ3BCLE1BQU07Z0JBQ3ZDLEdBQUdzQixPQUFPO2dCQUNWUixZQUFZUztZQUNoQixLQUFLM0IsSUFBSXdCLE1BQU07UUFDbkIsR0FDQSx1REFBdUQ7UUFDdkQ7WUFDSXRDO1lBQ0FQO1NBQ0g7UUFDRCxxQkFBcUI7UUFDckIsTUFBTW1ELFVBQVV6RSxrREFBV0EsQ0FBQyxDQUFDMEU7WUFDekIsOENBQThDO1lBQzlDLElBQUksQ0FBQzdDLGFBQWEsT0FBT2Y7WUFDekIsTUFBTSxHQUFHNkQsV0FBVyxHQUFHdkUsK0RBQWlCQSxDQUFDa0IsT0FBT087WUFDaEQsSUFBSU07WUFDSixJQUFJM0Isd0RBQVVBLENBQUNrRSxNQUFNO2dCQUNqQnZDLE9BQU91QyxJQUFJcEM7WUFDZixPQUFPLElBQUksT0FBT29DLE9BQU8sVUFBVTtnQkFDL0J2QyxPQUFPdUM7WUFDWDtZQUNBLElBQUksT0FBT3ZDLFFBQVEsVUFBVSxPQUFPckI7WUFDcEM2RCxXQUFXO2dCQUNQdkMsSUFBSUQ7WUFDUjtZQUNBSyxnQkFBZ0JDLE9BQU8sR0FBR047WUFDMUIsaURBQWlEO1lBQ2pELE1BQU1ZLE9BQU8sRUFBRTtZQUNmLE1BQU0sQ0FBQzZCLGlCQUFpQixHQUFHeEUsK0RBQWlCQSxDQUFDa0IsT0FBT087WUFDcEQsSUFBSXVCLG1CQUFtQjtZQUN2QixJQUFJLElBQUlDLElBQUksR0FBR0EsSUFBSWxCLE1BQU0sRUFBRWtCLEVBQUU7Z0JBQ3pCLE1BQU0sQ0FBQ0MsUUFBUSxHQUFHcEQsdURBQVNBLENBQUNVLE9BQU95QyxHQUFHRDtnQkFDdEMsTUFBTSxDQUFDSCxTQUFTLEdBQUc3QywrREFBaUJBLENBQUNrQixPQUFPZ0M7Z0JBQzVDLDRCQUE0QjtnQkFDNUIsTUFBTUksV0FBV0osVUFBVUwsV0FBV0YsSUFBSSxHQUFHeEMsbURBQVNBO2dCQUN0RCxnRkFBZ0Y7Z0JBQ2hGLElBQUlGLHlEQUFXQSxDQUFDcUQsV0FBVztvQkFDdkIsT0FBT1MsT0FBT1MsbUJBQW1CN0IsSUFBSTtnQkFDekM7Z0JBQ0FBLEtBQUtnQixJQUFJLENBQUNMO2dCQUNWTixtQkFBbUJNO1lBQ3ZCO1lBQ0EsT0FBT1MsT0FBT3BCO1FBQ2xCLEdBQ0EsdURBQXVEO1FBQ3ZEO1lBQ0lsQjtZQUNBUDtZQUNBNkM7WUFDQTdCO1NBQ0g7UUFDRCw0RUFBNEU7UUFDNUUsOENBQThDO1FBQzlDLE9BQU87WUFDSEgsTUFBTUc7WUFDTm1DO1lBQ0FOO1lBQ0EsSUFBSXBCLFFBQVE7Z0JBQ1IsT0FBT0osSUFBSUksSUFBSTtZQUNuQjtZQUNBLElBQUk4QixTQUFTO2dCQUNULE9BQU9sQyxJQUFJa0MsS0FBSztZQUNwQjtZQUNBLElBQUlDLGdCQUFnQjtnQkFDaEIsT0FBT25DLElBQUltQyxZQUFZO1lBQzNCO1lBQ0EsSUFBSUMsYUFBYTtnQkFDYixPQUFPcEMsSUFBSW9DLFNBQVM7WUFDeEI7UUFDSjtJQUNKO0FBQ0osTUFBTUMsaUJBQWlCN0UsNERBQWNBLENBQUNGLDJDQUFNQSxFQUFFZ0I7QUFFcUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWRlby1zdHJlYW1pbmcvLi9ub2RlX21vZHVsZXMvc3dyL2luZmluaXRlL2Rpc3QvaW5kZXgubWpzPzg5YmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlUmVmLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB1c2VTV1IgZnJvbSAnc3dyJztcbmltcG9ydCB7IHNlcmlhbGl6ZSwgd2l0aE1pZGRsZXdhcmUsIGNyZWF0ZUNhY2hlSGVscGVyLCBpc1VuZGVmaW5lZCwgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCwgVU5ERUZJTkVELCBpc0Z1bmN0aW9uIH0gZnJvbSAnc3dyL19pbnRlcm5hbCc7XG5pbXBvcnQgeyB1c2VTeW5jRXh0ZXJuYWxTdG9yZSB9IGZyb20gJ3VzZS1zeW5jLWV4dGVybmFsLXN0b3JlL3NoaW0vaW5kZXguanMnO1xuXG5jb25zdCBJTkZJTklURV9QUkVGSVggPSAnJGluZiQnO1xuY29uc3QgZ2V0Rmlyc3RQYWdlS2V5ID0gKGdldEtleSk9PntcbiAgICByZXR1cm4gc2VyaWFsaXplKGdldEtleSA/IGdldEtleSgwLCBudWxsKSA6IG51bGwpWzBdO1xufTtcbmNvbnN0IHVuc3RhYmxlX3NlcmlhbGl6ZSA9IChnZXRLZXkpPT57XG4gICAgcmV0dXJuIElORklOSVRFX1BSRUZJWCArIGdldEZpcnN0UGFnZUtleShnZXRLZXkpO1xufTtcblxuLy8gV2UgaGF2ZSB0byBzZXZlcmFsIHR5cGUgY2FzdGluZ3MgaGVyZSBiZWNhdXNlIGB1c2VTV1JJbmZpbml0ZWAgaXMgYSBzcGVjaWFsXG4vLyBjb25zdCBJTkZJTklURV9QUkVGSVggPSAnJGluZiQnXG5jb25zdCBFTVBUWV9QUk9NSVNFID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4vLyBleHBvcnQgY29uc3QgdW5zdGFibGVfc2VyaWFsaXplID0gKGdldEtleTogU1dSSW5maW5pdGVLZXlMb2FkZXIpID0+IHtcbi8vICAgcmV0dXJuIElORklOSVRFX1BSRUZJWCArIGdldEZpcnN0UGFnZUtleShnZXRLZXkpXG4vLyB9XG5jb25zdCBpbmZpbml0ZSA9ICh1c2VTV1JOZXh0KT0+KGdldEtleSwgZm4sIGNvbmZpZyk9PntcbiAgICAgICAgY29uc3QgZGlkTW91bnRSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICAgICAgICBjb25zdCB7IGNhY2hlICwgaW5pdGlhbFNpemUgPTEgLCByZXZhbGlkYXRlQWxsID1mYWxzZSAsIHBlcnNpc3RTaXplID1mYWxzZSAsIHJldmFsaWRhdGVGaXJzdFBhZ2UgPXRydWUgLCByZXZhbGlkYXRlT25Nb3VudCA9ZmFsc2UgLCBwYXJhbGxlbCA9ZmFsc2UgIH0gPSBjb25maWc7XG4gICAgICAgIC8vIFRoZSBzZXJpYWxpemVkIGtleSBvZiB0aGUgZmlyc3QgcGFnZS4gVGhpcyBrZXkgd2lsbCBiZSB1c2VkIHRvIHN0b3JlXG4gICAgICAgIC8vIG1ldGFkYXRhIG9mIHRoaXMgU1dSIGluZmluaXRlIGhvb2suXG4gICAgICAgIGxldCBpbmZpbml0ZUtleTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGluZmluaXRlS2V5ID0gZ2V0Rmlyc3RQYWdlS2V5KGdldEtleSk7XG4gICAgICAgICAgICBpZiAoaW5maW5pdGVLZXkpIGluZmluaXRlS2V5ID0gSU5GSU5JVEVfUFJFRklYICsgaW5maW5pdGVLZXk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAvLyBOb3QgcmVhZHkgeWV0LlxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtnZXQsIHNldCwgc3Vic2NyaWJlQ2FjaGVdID0gY3JlYXRlQ2FjaGVIZWxwZXIoY2FjaGUsIGluZmluaXRlS2V5KTtcbiAgICAgICAgY29uc3QgZ2V0U25hcHNob3QgPSB1c2VDYWxsYmFjaygoKT0+e1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGlzVW5kZWZpbmVkKGdldCgpLl9sKSA/IGluaXRpYWxTaXplIDogZ2V0KCkuX2w7XG4gICAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgICAgICB9LCBbXG4gICAgICAgICAgICBjYWNoZSxcbiAgICAgICAgICAgIGluZmluaXRlS2V5LFxuICAgICAgICAgICAgaW5pdGlhbFNpemVcbiAgICAgICAgXSk7XG4gICAgICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlKHVzZUNhbGxiYWNrKChjYWxsYmFjayk9PntcbiAgICAgICAgICAgIGlmIChpbmZpbml0ZUtleSkgcmV0dXJuIHN1YnNjcmliZUNhY2hlKGluZmluaXRlS2V5LCAoKT0+e1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAoKT0+e307XG4gICAgICAgIH0sIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICAgICAgW1xuICAgICAgICAgICAgY2FjaGUsXG4gICAgICAgICAgICBpbmZpbml0ZUtleVxuICAgICAgICBdKSwgZ2V0U25hcHNob3QsIGdldFNuYXBzaG90KTtcbiAgICAgICAgY29uc3QgcmVzb2x2ZVBhZ2VTaXplID0gdXNlQ2FsbGJhY2soKCk9PntcbiAgICAgICAgICAgIGNvbnN0IGNhY2hlZFBhZ2VTaXplID0gZ2V0KCkuX2w7XG4gICAgICAgICAgICByZXR1cm4gaXNVbmRlZmluZWQoY2FjaGVkUGFnZVNpemUpID8gaW5pdGlhbFNpemUgOiBjYWNoZWRQYWdlU2l6ZTtcbiAgICAgICAgLy8gYGNhY2hlYCBpc24ndCBhbGxvd2VkIHRvIGNoYW5nZSBkdXJpbmcgdGhlIGxpZmVjeWNsZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgICAgIH0sIFtcbiAgICAgICAgICAgIGluZmluaXRlS2V5LFxuICAgICAgICAgICAgaW5pdGlhbFNpemVcbiAgICAgICAgXSk7XG4gICAgICAgIC8vIGtlZXAgdGhlIGxhc3QgcGFnZSBzaXplIHRvIHJlc3RvcmUgaXQgd2l0aCB0aGUgcGVyc2lzdFNpemUgb3B0aW9uXG4gICAgICAgIGNvbnN0IGxhc3RQYWdlU2l6ZVJlZiA9IHVzZVJlZihyZXNvbHZlUGFnZVNpemUoKSk7XG4gICAgICAgIC8vIFdoZW4gdGhlIHBhZ2Uga2V5IGNoYW5nZXMsIHdlIHJlc2V0IHRoZSBwYWdlIHNpemUgaWYgaXQncyBub3QgcGVyc2lzdGVkXG4gICAgICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCk9PntcbiAgICAgICAgICAgIGlmICghZGlkTW91bnRSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIGRpZE1vdW50UmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbmZpbml0ZUtleSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBrZXkgaGFzIGJlZW4gY2hhbmdlZCwgd2Uga2VlcCB0aGUgY3VycmVudCBwYWdlIHNpemUgaWYgcGVyc2lzdFNpemUgaXMgZW5hYmxlZFxuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UgcmVzZXQgdGhlIHBhZ2Ugc2l6ZSB0byBjYWNoZWQgcGFnZVNpemVcbiAgICAgICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICAgICAgICBfbDogcGVyc2lzdFNpemUgPyBsYXN0UGFnZVNpemVSZWYuY3VycmVudCA6IHJlc29sdmVQYWdlU2l6ZSgpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIC8vIGBpbml0aWFsU2l6ZWAgaXNuJ3QgYWxsb3dlZCB0byBjaGFuZ2UgZHVyaW5nIHRoZSBsaWZlY3ljbGVcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgICAgICB9LCBbXG4gICAgICAgICAgICBpbmZpbml0ZUtleSxcbiAgICAgICAgICAgIGNhY2hlXG4gICAgICAgIF0pO1xuICAgICAgICAvLyBOZWVkcyB0byBjaGVjayBkaWRNb3VudFJlZiBkdXJpbmcgbW91bnRpbmcsIG5vdCBpbiB0aGUgZmV0Y2hlclxuICAgICAgICBjb25zdCBzaG91bGRSZXZhbGlkYXRlT25Nb3VudCA9IHJldmFsaWRhdGVPbk1vdW50ICYmICFkaWRNb3VudFJlZi5jdXJyZW50O1xuICAgICAgICAvLyBBY3R1YWwgU1dSIGhvb2sgdG8gbG9hZCBhbGwgcGFnZXMgaW4gb25lIGZldGNoZXIuXG4gICAgICAgIGNvbnN0IHN3ciA9IHVzZVNXUk5leHQoaW5maW5pdGVLZXksIGFzeW5jIChrZXkpPT57XG4gICAgICAgICAgICAvLyBnZXQgdGhlIHJldmFsaWRhdGUgY29udGV4dFxuICAgICAgICAgICAgY29uc3QgZm9yY2VSZXZhbGlkYXRlQWxsID0gZ2V0KCkuX2k7XG4gICAgICAgICAgICAvLyByZXR1cm4gYW4gYXJyYXkgb2YgcGFnZSBkYXRhXG4gICAgICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgICAgICBjb25zdCBwYWdlU2l6ZSA9IHJlc29sdmVQYWdlU2l6ZSgpO1xuICAgICAgICAgICAgY29uc3QgW2dldENhY2hlXSA9IGNyZWF0ZUNhY2hlSGVscGVyKGNhY2hlLCBrZXkpO1xuICAgICAgICAgICAgY29uc3QgY2FjaGVEYXRhID0gZ2V0Q2FjaGUoKS5kYXRhO1xuICAgICAgICAgICAgY29uc3QgcmV2YWxpZGF0b3JzID0gW107XG4gICAgICAgICAgICBsZXQgcHJldmlvdXNQYWdlRGF0YSA9IG51bGw7XG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgcGFnZVNpemU7ICsraSl7XG4gICAgICAgICAgICAgICAgY29uc3QgW3BhZ2VLZXksIHBhZ2VBcmddID0gc2VyaWFsaXplKGdldEtleShpLCBwYXJhbGxlbCA/IG51bGwgOiBwcmV2aW91c1BhZ2VEYXRhKSk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYWdlS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBbZ2V0U1dSQ2FjaGUsIHNldFNXUkNhY2hlXSA9IGNyZWF0ZUNhY2hlSGVscGVyKGNhY2hlLCBwYWdlS2V5KTtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGNhY2hlZCBwYWdlIGRhdGEuXG4gICAgICAgICAgICAgICAgbGV0IHBhZ2VEYXRhID0gZ2V0U1dSQ2FjaGUoKS5kYXRhO1xuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBmZXRjaCAob3IgcmV2YWxpZGF0ZSkgaWY6XG4gICAgICAgICAgICAgICAgLy8gLSBgcmV2YWxpZGF0ZUFsbGAgaXMgZW5hYmxlZFxuICAgICAgICAgICAgICAgIC8vIC0gYG11dGF0ZSgpYCBjYWxsZWRcbiAgICAgICAgICAgICAgICAvLyAtIHRoZSBjYWNoZSBpcyBtaXNzaW5nXG4gICAgICAgICAgICAgICAgLy8gLSBpdCdzIHRoZSBmaXJzdCBwYWdlIGFuZCBpdCdzIG5vdCB0aGUgaW5pdGlhbCByZW5kZXJcbiAgICAgICAgICAgICAgICAvLyAtIGByZXZhbGlkYXRlT25Nb3VudGAgaXMgZW5hYmxlZCBhbmQgaXQncyBvbiBtb3VudFxuICAgICAgICAgICAgICAgIC8vIC0gY2FjaGUgZm9yIHRoYXQgcGFnZSBoYXMgY2hhbmdlZFxuICAgICAgICAgICAgICAgIGNvbnN0IHNob3VsZEZldGNoUGFnZSA9IHJldmFsaWRhdGVBbGwgfHwgZm9yY2VSZXZhbGlkYXRlQWxsIHx8IGlzVW5kZWZpbmVkKHBhZ2VEYXRhKSB8fCByZXZhbGlkYXRlRmlyc3RQYWdlICYmICFpICYmICFpc1VuZGVmaW5lZChjYWNoZURhdGEpIHx8IHNob3VsZFJldmFsaWRhdGVPbk1vdW50IHx8IGNhY2hlRGF0YSAmJiAhaXNVbmRlZmluZWQoY2FjaGVEYXRhW2ldKSAmJiAhY29uZmlnLmNvbXBhcmUoY2FjaGVEYXRhW2ldLCBwYWdlRGF0YSk7XG4gICAgICAgICAgICAgICAgaWYgKGZuICYmIHNob3VsZEZldGNoUGFnZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXZhbGlkYXRlID0gYXN5bmMgKCk9PntcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhZ2VEYXRhID0gYXdhaXQgZm4ocGFnZUFyZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRTV1JDYWNoZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogcGFnZURhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2s6IHBhZ2VBcmdcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtpXSA9IHBhZ2VEYXRhO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYWxsZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldmFsaWRhdG9ycy5wdXNoKHJldmFsaWRhdGUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXdhaXQgcmV2YWxpZGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpXSA9IHBhZ2VEYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXBhcmFsbGVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzUGFnZURhdGEgPSBwYWdlRGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmbHVzaCBhbGwgcmV2YWxpZGF0ZWlvbnMgaW4gcGFyYWxsZWxcbiAgICAgICAgICAgIGlmIChwYXJhbGxlbCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHJldmFsaWRhdG9ycy5tYXAoKHIpPT5yKCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG9uY2Ugd2UgZXhlY3V0ZWQgdGhlIGRhdGEgZmV0Y2hpbmcgYmFzZWQgb24gdGhlIGNvbnRleHQsIGNsZWFyIHRoZSBjb250ZXh0XG4gICAgICAgICAgICBzZXQoe1xuICAgICAgICAgICAgICAgIF9pOiBVTkRFRklORURcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gcmV0dXJuIHRoZSBkYXRhXG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSwgY29uZmlnKTtcbiAgICAgICAgY29uc3QgbXV0YXRlID0gdXNlQ2FsbGJhY2soLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgICAgICAgZnVuY3Rpb24oZGF0YSwgb3B0cykge1xuICAgICAgICAgICAgLy8gV2hlbiBwYXNzaW5nIGFzIGEgYm9vbGVhbiwgaXQncyBleHBsaWNpdGx5IHVzZWQgdG8gZGlzYWJsZS9lbmFibGVcbiAgICAgICAgICAgIC8vIHJldmFsaWRhdGlvbi5cbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB0eXBlb2Ygb3B0cyA9PT0gJ2Jvb2xlYW4nID8ge1xuICAgICAgICAgICAgICAgIHJldmFsaWRhdGU6IG9wdHNcbiAgICAgICAgICAgIH0gOiBvcHRzIHx8IHt9O1xuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byB0cnVlLlxuICAgICAgICAgICAgY29uc3Qgc2hvdWxkUmV2YWxpZGF0ZSA9IG9wdGlvbnMucmV2YWxpZGF0ZSAhPT0gZmFsc2U7XG4gICAgICAgICAgICAvLyBJdCBpcyBwb3NzaWJsZSB0aGF0IHRoZSBrZXkgaXMgc3RpbGwgZmFsc3kuXG4gICAgICAgICAgICBpZiAoIWluZmluaXRlS2V5KSByZXR1cm4gRU1QVFlfUFJPTUlTRTtcbiAgICAgICAgICAgIGlmIChzaG91bGRSZXZhbGlkYXRlKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChkYXRhKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IHJldmFsaWRhdGUgdGhlIHBhZ2VzIHRoYXQgYXJlIGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgc2V0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBDYWxsaW5nIGBtdXRhdGUoKWAsIHdlIHJldmFsaWRhdGUgYWxsIHBhZ2VzXG4gICAgICAgICAgICAgICAgICAgIHNldCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaTogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHN3ci5tdXRhdGUoZGF0YSwge1xuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAgcmV2YWxpZGF0ZTogc2hvdWxkUmV2YWxpZGF0ZVxuICAgICAgICAgICAgfSkgOiBzd3IubXV0YXRlKCk7XG4gICAgICAgIH0sIC8vIHN3ci5tdXRhdGUgaXMgYWx3YXlzIHRoZSBzYW1lIHJlZmVyZW5jZVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gICAgICAgIFtcbiAgICAgICAgICAgIGluZmluaXRlS2V5LFxuICAgICAgICAgICAgY2FjaGVcbiAgICAgICAgXSk7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgU1dSIEFQSVxuICAgICAgICBjb25zdCBzZXRTaXplID0gdXNlQ2FsbGJhY2soKGFyZyk9PntcbiAgICAgICAgICAgIC8vIEl0IGlzIHBvc3NpYmxlIHRoYXQgdGhlIGtleSBpcyBzdGlsbCBmYWxzeS5cbiAgICAgICAgICAgIGlmICghaW5maW5pdGVLZXkpIHJldHVybiBFTVBUWV9QUk9NSVNFO1xuICAgICAgICAgICAgY29uc3QgWywgY2hhbmdlU2l6ZV0gPSBjcmVhdGVDYWNoZUhlbHBlcihjYWNoZSwgaW5maW5pdGVLZXkpO1xuICAgICAgICAgICAgbGV0IHNpemU7XG4gICAgICAgICAgICBpZiAoaXNGdW5jdGlvbihhcmcpKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSA9IGFyZyhyZXNvbHZlUGFnZVNpemUoKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmcgPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBzaXplID0gYXJnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBzaXplICE9ICdudW1iZXInKSByZXR1cm4gRU1QVFlfUFJPTUlTRTtcbiAgICAgICAgICAgIGNoYW5nZVNpemUoe1xuICAgICAgICAgICAgICAgIF9sOiBzaXplXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxhc3RQYWdlU2l6ZVJlZi5jdXJyZW50ID0gc2l6ZTtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgcGFnZSBkYXRhIGFmdGVyIHRoZSBzaXplIGNoYW5nZS5cbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IFtnZXRJbmZpbml0ZUNhY2hlXSA9IGNyZWF0ZUNhY2hlSGVscGVyKGNhY2hlLCBpbmZpbml0ZUtleSk7XG4gICAgICAgICAgICBsZXQgcHJldmlvdXNQYWdlRGF0YSA9IG51bGw7XG4gICAgICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgc2l6ZTsgKytpKXtcbiAgICAgICAgICAgICAgICBjb25zdCBbcGFnZUtleV0gPSBzZXJpYWxpemUoZ2V0S2V5KGksIHByZXZpb3VzUGFnZURhdGEpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBbZ2V0Q2FjaGVdID0gY3JlYXRlQ2FjaGVIZWxwZXIoY2FjaGUsIHBhZ2VLZXkpO1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgY2FjaGVkIHBhZ2UgZGF0YS5cbiAgICAgICAgICAgICAgICBjb25zdCBwYWdlRGF0YSA9IHBhZ2VLZXkgPyBnZXRDYWNoZSgpLmRhdGEgOiBVTkRFRklORUQ7XG4gICAgICAgICAgICAgICAgLy8gQ2FsbCBgbXV0YXRlYCB3aXRoIGluZmludGUgY2FjaGUgZGF0YSBpZiB3ZSBjYW4ndCBnZXQgaXQgZnJvbSB0aGUgcGFnZSBjYWNoZS5cbiAgICAgICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQocGFnZURhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtdXRhdGUoZ2V0SW5maW5pdGVDYWNoZSgpLmRhdGEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkYXRhLnB1c2gocGFnZURhdGEpO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzUGFnZURhdGEgPSBwYWdlRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtdXRhdGUoZGF0YSk7XG4gICAgICAgIH0sIC8vIGV4Y2x1ZGUgZ2V0S2V5IGZyb20gdGhlIGRlcGVuZGVuY2llcywgd2hpY2ggaXNuJ3QgYWxsb3dlZCB0byBjaGFuZ2UgZHVyaW5nIHRoZSBsaWZlY3ljbGVcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgICAgICBbXG4gICAgICAgICAgICBpbmZpbml0ZUtleSxcbiAgICAgICAgICAgIGNhY2hlLFxuICAgICAgICAgICAgbXV0YXRlLFxuICAgICAgICAgICAgcmVzb2x2ZVBhZ2VTaXplXG4gICAgICAgIF0pO1xuICAgICAgICAvLyBVc2UgZ2V0dGVyIGZ1bmN0aW9ucyB0byBhdm9pZCB1bm5lY2Vzc2FyeSByZS1yZW5kZXJzIGNhdXNlZCBieSB0cmlnZ2VyaW5nXG4gICAgICAgIC8vIGFsbCB0aGUgZ2V0dGVycyBvZiB0aGUgcmV0dXJuZWQgc3dyIG9iamVjdC5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNpemU6IHJlc29sdmVQYWdlU2l6ZSgpLFxuICAgICAgICAgICAgc2V0U2l6ZSxcbiAgICAgICAgICAgIG11dGF0ZSxcbiAgICAgICAgICAgIGdldCBkYXRhICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3dyLmRhdGE7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IGVycm9yICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3dyLmVycm9yO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBpc1ZhbGlkYXRpbmcgKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzd3IuaXNWYWxpZGF0aW5nO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBpc0xvYWRpbmcgKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzd3IuaXNMb2FkaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5jb25zdCB1c2VTV1JJbmZpbml0ZSA9IHdpdGhNaWRkbGV3YXJlKHVzZVNXUiwgaW5maW5pdGUpO1xuXG5leHBvcnQgeyB1c2VTV1JJbmZpbml0ZSBhcyBkZWZhdWx0LCBpbmZpbml0ZSwgdW5zdGFibGVfc2VyaWFsaXplIH07XG4iXSwibmFtZXMiOlsidXNlUmVmIiwidXNlQ2FsbGJhY2siLCJ1c2VTV1IiLCJzZXJpYWxpemUiLCJ3aXRoTWlkZGxld2FyZSIsImNyZWF0ZUNhY2hlSGVscGVyIiwiaXNVbmRlZmluZWQiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwiVU5ERUZJTkVEIiwiaXNGdW5jdGlvbiIsInVzZVN5bmNFeHRlcm5hbFN0b3JlIiwiSU5GSU5JVEVfUFJFRklYIiwiZ2V0Rmlyc3RQYWdlS2V5IiwiZ2V0S2V5IiwidW5zdGFibGVfc2VyaWFsaXplIiwiRU1QVFlfUFJPTUlTRSIsIlByb21pc2UiLCJyZXNvbHZlIiwiaW5maW5pdGUiLCJ1c2VTV1JOZXh0IiwiZm4iLCJjb25maWciLCJkaWRNb3VudFJlZiIsImNhY2hlIiwiaW5pdGlhbFNpemUiLCJyZXZhbGlkYXRlQWxsIiwicGVyc2lzdFNpemUiLCJyZXZhbGlkYXRlRmlyc3RQYWdlIiwicmV2YWxpZGF0ZU9uTW91bnQiLCJwYXJhbGxlbCIsImluZmluaXRlS2V5IiwiZXJyIiwiZ2V0Iiwic2V0Iiwic3Vic2NyaWJlQ2FjaGUiLCJnZXRTbmFwc2hvdCIsInNpemUiLCJfbCIsImNhbGxiYWNrIiwicmVzb2x2ZVBhZ2VTaXplIiwiY2FjaGVkUGFnZVNpemUiLCJsYXN0UGFnZVNpemVSZWYiLCJjdXJyZW50Iiwic2hvdWxkUmV2YWxpZGF0ZU9uTW91bnQiLCJzd3IiLCJrZXkiLCJmb3JjZVJldmFsaWRhdGVBbGwiLCJfaSIsImRhdGEiLCJwYWdlU2l6ZSIsImdldENhY2hlIiwiY2FjaGVEYXRhIiwicmV2YWxpZGF0b3JzIiwicHJldmlvdXNQYWdlRGF0YSIsImkiLCJwYWdlS2V5IiwicGFnZUFyZyIsImdldFNXUkNhY2hlIiwic2V0U1dSQ2FjaGUiLCJwYWdlRGF0YSIsInNob3VsZEZldGNoUGFnZSIsImNvbXBhcmUiLCJyZXZhbGlkYXRlIiwiX2siLCJwdXNoIiwiYWxsIiwibWFwIiwiciIsIm11dGF0ZSIsIm9wdHMiLCJvcHRpb25zIiwic2hvdWxkUmV2YWxpZGF0ZSIsImFyZ3VtZW50cyIsImxlbmd0aCIsInNldFNpemUiLCJhcmciLCJjaGFuZ2VTaXplIiwiZ2V0SW5maW5pdGVDYWNoZSIsImVycm9yIiwiaXNWYWxpZGF0aW5nIiwiaXNMb2FkaW5nIiwidXNlU1dSSW5maW5pdGUiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/swr/infinite/dist/index.mjs\n");

/***/ })

};
;